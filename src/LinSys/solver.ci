// *****************************************************************************
/*!
  \file      src/LinSys/solver.ci
  \copyright 2012-2015, J. Bakosi, 2016-2017, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system. See more
     in src/LinSys/Solver.h.
*/
// *****************************************************************************

module solver {

  namespace tk {

    group Solver {
      entry Solver( const std::vector< CkCallback >& cb,
                    const std::map< int,
                      std::vector< std::size_t > >& side,
                    std::size_t ncomp,
                    bool feedback );
      entry void nchare( int n );
      initnode void registerBCMerger();
      entry void bounds( int pe, std::size_t lower, std::size_t upper );
      entry void next();
      entry void addrow( int fromch,
                         int frompe,
                         const std::set< std::size_t >& row );
      entry void recrow();
      entry [reductiontarget] void addbc( CkReductionMsg* msg );
      entry void addsol( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& solution );
      entry void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry void addlowrhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& lorhs );
      entry void addlowlhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& lolhs );
      entry void adddiag( int fromch,
                          std::map< std::size_t,
                           std::vector< std::vector< tk::real > > >& solution );
      entry void comfinal();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //
      // See src/LinSys/Solver.h.
      //
      // Interpretation of the DAG in src/LinSys/Solver.h
      // ------------------------------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // We start out with all worker chares contributing their porition of the
      // global row IDs that each work on. This is labelled ChRow. The worker
      // chares also contribute, in parallel, their portion of the global node
      // ID lists at which they can set boundary conditions, labelled, ChBCs.
      // Once both row IDs and BC node lists are received on Solver, we do a
      // global reduction to Transport::comfinal() which spawns two broadcasts:
      // (1) Solver::comfinal(), and (2) worker::init().
      //
      // Solver::comfinal() path: The member function tk::Solver::comfinal(),
      // labeled ComFinal in the task-graph, triggers and performs the following
      // tasks: (1) Verification that ensures consistent global row IDs,
      // signaling the all communication (maps) are final. (2) The second step
      // in tk::Solver::comfinal() initiates is building Hypre data from the
      // global row indices received, labeled HypreRow.
      //
      // Worker::init() path: Once the row IDs are contributed,
      // Transporter::comfinal(), not only spaws tk::Solver::comfinal() but also
      // issues a broadcast to the worker chares to start initializing their
      // system. This is started with a call to the init() member function of
      // the worker. The tasks done in init() include setting initial and
      // boundary conditions, sending unknown/solution vectors for assembly to
      // Solver, start computing the minimum time step size, outputing initial
      // field data to file, start computing the left hand sides for both the
      // high-, and low-order linear systems, and sending all this for linear
      // system assembly. The contribution goes to those Linear System Merger
      // group branch (one per CPU) the workers happen to reside on. These steps
      // are denoted by ChSol, ChLhs, and ChLoLhs in the graph above, and the
      // contributions/assembly is performed by the member functions charesol(),
      // charelhs(), and charelolhs(), respectively.
      //
      // Among other tasks, worker::init(), discussed above, also start
      // computing the minimum time step sizes based on all PDEs integrated.
      // Once a worker has finished with that task, it sends it contribution of
      // the smallest dt for computing a global minimum in Transporter::dt(),
      // which then spawns a broadcast to the workers to start advancing their
      // PDEs, which consists of computing the right hand sides for both the
      // high-, and low-order linear systems, ChRhs, ChLoRhs. These right hand
      // sides can only be comnputed if the dt is available.
      //
      // Once the collection of the right hand side vector, ChRhs, is done, we
      // set boundary conditions on the RHS vector, RhsBC. Once the collection
      // of the left hand side matrix, ChLhs, is done, we set boundary
      // conditions on the LHS matrix, LhsBC.
      //
      // High-order solution only: Once each of the tasks, ChSol, LhsBC, and
      // RhsBC, (not all at the same time but separately) are done, we continue
      // by converting these data structures to a format that Hypre expects,
      // done in hypresol(), hyprelhs(), and hyprerhs(), denoted by similars
      // labels in the graph. These functions basically flatten the C++ data
      // structures to C-style arrays and linked arrays (for the matrix). Note
      // that the left and right hand sides can only begin to be converted to
      // Hypre data format if the boundary conditions have also been applied on
      // each.
      //
      // High-order solution only: Once the tasks, HypreSol, HypreLhs, HypreRhs,
      // (not all at the same time but separately) are done and the Hypre data
      // structure for the row IDs are complete, we continue by assigning the
      // flattened data structures (more precisely, their pointers) to the Hypre
      // vectors and Hypre matrix. These are denoted FillSol, FillLhs, and
      // FillRhs in the DAG and correspond to the member functions sol(), lhs(),
      // and rhs().
      //
      // High-order solution only: Once the tasks, FillSol, FillLhs, FIllRhs,
      // (not all at the same time, but separately) are, we continue by calling
      // the Hypre "assembly" routines for the solution vector, the left hand
      // side matrix, and the right hand side vector. These are denoted by
      // AsmSol, AsmLhs, and AsmRhs in the DAG, and performed by the member
      // functions assemblesol(), assemblelhs(), and assemblerhs(),
      // respectively.
      //
      // High-order solution only: Once the assembly of the solution (unknown)
      // vector, the left hand side matrix, and the right hand side vector are
      // all done (on a CPU), labels AsmSol, AsmLhs, AsmRhs, respectively, we
      // call the solve() member function which solves the high-order linear
      // system by calling Hypre and also updates the high-order solution, i.e.,
      // propagates the new solution back to the worker chares, labeled Upd.
      //
      // Low-order solution only: The low-order solution is performed once the
      // boundary conditions have been set on the high-order right hand side
      // vector (RhsBC), the low-order rhs vector, combined with the high-order
      // rhs (LoRhs) has been ready, and the low-order left hand side (LoLhs)
      // are all complete. The solution of the low-order system is a simple
      // back-substitution, since the system is assumed diagonal. Note also,
      // that due to the way FluxCorrector::aec() computes the antidiffusive
      // element contributions and the way it applies the limiter in
      // FluxCorrector::lim(), there is no need to set Dirichlet boundary
      // conditions on the low-order system. See more details in
      // FluxCorrector::aec().
      //
      // A word on multiple invokation of SDAG triggers: As the commit message
      // of b79ea29 explains, the "triggers", such as lhsbc_complete(),
      // enumerated below, at threir call site should be thought of as messages
      // being put in some message queue and consumed at 'when' clauses wherever
      // they appear. If they appear in multiple when clauses, they consume
      // multple messages, thus they have to be triggered multiple times. See
      // https://lists.cs.illinois.edu/lists/arc/charm/2016-09/msg00002.html.

      entry void wait4nchare() {
        when nchare_complete(), bounds_complete() serial "nchare" {
          contribute( m_cb.get< tag::coord >() ); } };

      entry void wait4lhsbc() {
        when lhs_complete(), bc_complete_lhs() serial "lhsbc" { lhsbc(); } };
      entry void wait4rhsbc() {
        when rhs_complete(), bc_complete_rhs(), lhsbc_complete()
          serial "rhsbc" { rhsbc(); } };

      entry void wait4lhs() {
        when lhsbc_complete() serial "hyprelhs" { hyprelhs(); } };
      entry void wait4rhs() {
        when rhsbc_complete() serial "hyprerhs" { hyprerhs(); } };

      entry void wait4hypresol() {
        when hypresol_complete(), hyprerow_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs() {
        when hyprelhs_complete(), hyprerow_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs() {
        when hyprerhs_complete(), hyprerow_complete() serial "rhs" { rhs(); } };

      entry void wait4asm() {
        when asmsol_complete(), asmlhs_complete(), asmrhs_complete()
          serial "solve" { solve(); } };
      entry void wait4low() {
        when rhsbc_complete(), lowlhs_complete(), lowrhs_complete()
          serial "low" { lowsolve(); } };

      entry void nchare_complete();
      entry void bounds_complete();
      entry void bc_complete_lhs();
      entry void bc_complete_rhs();
      entry void lhsbc_complete();
      entry void rhsbc_complete();
      entry void hyprerow_complete();
      entry void lhs_complete();
      entry void rhs_complete();
      entry void lowrhs_complete();
      entry void lowlhs_complete();
      entry void hyprelhs_complete();
      entry void hyprerhs_complete();
      entry void hypresol_complete();
      entry void asmlhs_complete();
      entry void asmrhs_complete();
      entry void asmsol_complete();
    };

  } // tk::

}
