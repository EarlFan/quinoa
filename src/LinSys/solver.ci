// *****************************************************************************
/*!
  \file      src/LinSys/solver.ci
  \copyright 2012-2015, J. Bakosi, 2016-2018, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for merging a linear system
  \details   Charm++ module interface file for merging a linear system. See more
     in src/LinSys/Solver.h.
*/
// *****************************************************************************

module solver {

  include "Callback.h";
  include "Fields.h";

  namespace tk {

    nodegroup Solver {
      entry Solver( const SolverCallback& cb, std::size_t ncomp );
      entry [exclusive] void nchare( int n );
      entry [exclusive] void chbounds( std::size_t lower, std::size_t upper );
      entry [exclusive]
        void nodebounds( int n, std::size_t lower, std::size_t upper );
      entry [exclusive] void next();
      entry [exclusive] void charecom( int fromch, const MatCGCallback& cb );
      entry [exclusive]
        void charerow( int fromch, const std::vector< std::size_t >& row );
      entry [exclusive] void addrow( int fromch,
                                     int fromnode,
                                     const std::set< std::size_t >& row );
      entry [exclusive] void recrow();
      entry [exclusive] void charesol( int fromch,
                                       const std::vector< std::size_t >& gid,
                                       const Fields& solution );
      entry [exclusive] void addsol( int fromch,
                                     const std::map< std::size_t,
                                       std::vector< tk::real > >& solution );
      entry [exclusive] void charelhs( int fromch,
                           const std::vector< std::size_t >& gid,
                           const std::pair< std::vector< std::size_t >,
                                            std::vector< std::size_t > >& psup,
                           const tk::Fields& lhsd,
                           const tk::Fields& lhso );
      entry [exclusive] void addlhs( int fromch,
        const std::map< std::size_t,
                        std::map< std::size_t,
                                  std::vector< tk::real > > >& lhs );
      entry [exclusive] void charerhs( int fromch,
                           const std::vector< std::size_t >& gid,
                           const Fields& r );
      entry [exclusive] void addrhs( int fromch,
                         const std::map< std::size_t,
                                         std::vector< tk::real > >& rhs );
      entry [exclusive] void charelowrhs( int fromch,
                              const std::vector< std::size_t >& gid,
                              const Fields& lowrhs );
      entry [exclusive] void addlowrhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& lorhs );
      entry [exclusive] void charelowlhs( int fromch,
                              const std::vector< std::size_t >& gid,
                              const Fields& lowlhs );
      entry [exclusive] void addlowlhs( int fromch,
                            const std::map< std::size_t,
                                            std::vector< tk::real > >& lolhs );
      entry [exclusive] void comfinal();
      entry [exclusive] void charebc( const std::unordered_map< std::size_t,
                            std::vector< std::pair< bool, tk::real > > >& bc );

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // A word on multiple invokation of SDAG triggers: As the commit message
      // of b79ea29 explains, the "triggers", such as hyprerow_complete(),
      // enumerated below, at threir call site should be thought of as messages
      // being put in some message queue and consumed at 'when' clauses wherever
      // they appear. If they appear in multiple when clauses, they consume
      // multple messages, thus they have to be triggered multiple times. See
      // https://lists.cs.illinois.edu/lists/arc/charm/2016-09/msg00002.html.

      entry void wait4com() {
        when com_complete(), row_complete() serial "com" {
          contribute( m_cb.get< tag::com >() ); } };

      entry void wait4lhsbc() {
        when lhs_complete(), bc_complete() serial "lhsbc" { lhsbc(); } };
      entry void wait4rhsbc() {
        when rhs_complete(), bc_complete() serial "rhsbc" { rhsbc(); } };

      entry void wait4hypresol() {
        when hypresol_complete(), hyprerow_complete() serial "sol" { sol(); } };
      entry void wait4hyprelhs() {
        when hyprelhs_complete(), hyprerow_complete() serial "lhs" { lhs(); } };
      entry void wait4hyprerhs() {
        when hyprerhs_complete(), hyprerow_complete() serial "rhs" { rhs(); } };

      entry void wait4asm() {
        when asmsol_complete(), asmlhs_complete(), asmrhs_complete()
          serial "solve" { solve(); } };
      entry void wait4low() {
        when rhsbc_complete(), lowlhs_complete(), lowrhs_complete()
          serial "low" { lowsolve(); } };

      entry void com_complete();
      entry void row_complete();
      entry void bc_complete();
      entry void rhsbc_complete();
      entry void hyprerow_complete();
      entry void lhs_complete();
      entry void rhs_complete();
      entry void lowrhs_complete();
      entry void lowlhs_complete();
      entry void hyprelhs_complete();
      entry void hyprerhs_complete();
      entry void hypresol_complete();
      entry void asmlhs_complete();
      entry void asmrhs_complete();
      entry void asmsol_complete();
    };

  } // tk::

}
