// *****************************************************************************
/*!
  \file      src/Inciter/transporter.ci
  \copyright 2012-2015, J. Bakosi, 2016-2017, Los Alamos National Security, LLC.
  \brief     Charm++ module interface file for Transporter
  \details   Charm++ module interface file for Transporter
*/
// *****************************************************************************

module transporter {

  include "Types.h";

  extern module boundaryconditions;

  namespace inciter {

    chare Transporter {
      entry Transporter();
      entry [reductiontarget] void load( uint64_t nelem );
      entry [reductiontarget] void part();
      entry [reductiontarget] void distributed();
      entry [reductiontarget] void flattened();
      entry [reductiontarget] void coord();
      entry [reductiontarget] void comfinal();
      entry [reductiontarget] void totalvol( tk::real v );
      entry [reductiontarget] void vol();
      entry [reductiontarget] void minstat( tk::real d[n], std::size_t n );
      entry [reductiontarget] void maxstat( tk::real d[n], std::size_t n );
      entry [reductiontarget] void sumstat( tk::real d[n], std::size_t n );
      entry [reductiontarget] void pdfstat( CkReductionMsg* msg );
      entry [reductiontarget] void aveCost( tk::real c );
      entry [reductiontarget] void stdCost( tk::real c );
      entry [reductiontarget] void diagnostics( CkReductionMsg* msg );
      entry [reductiontarget] void start();
      entry [reductiontarget] void next();
      entry [reductiontarget] void finish();

      entry void pegraph();

      entry void pepartitioned();
      entry void pedistributed();

      entry void peflattened();
      entry void pemask();
      entry void pereordered();
      entry void pebounds();

      entry void pecomfinal();
      entry void chbcmatched();
      entry void pebccomplete();

      entry void chrhs();
      entry void pesolve();
      entry void chlim();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      // High-level overview of the dependency and asynchronous call structure
      // ---------------------------------------------------------------------
      //
      // Directed Acyclic Graph (DAG):
      // -----------------------------
      //
      // See src/Inciter/Transporter.h.
      //
      // Interpretation of the above DAG
      // -------------------------------
      // Control flow is from left to right and top to bottom.
      //
      // Only when the mesh cells are read in from file, the computational load
      // can be computed in load(), and only when everything is setup for mesh
      // partitioning, can mesh partitioning start, by calling
      // Partitioner::partition(). More details in 66d35608.
      //
      // MinStat, MaxStat, SumStat, and PdfStat denote different global
      // reductions used to compute mesh cell statistics. Only when all of these
      // are completed will they be echoed to screen at once, denoted by Stat.

      entry void wait4part() {
        when load_complete(), part_complete() serial "part" {
          m_partitioner.partition( m_nchare ); } };

      entry void wait4stat() {
        when minstat_complete(), maxstat_complete(), sumstat_complete(),
             pdfstat_complete(), com_complete() serial "stat" { stat(); } };

      entry void load_complete();
      entry void part_complete();
      entry void minstat_complete();
      entry void maxstat_complete();
      entry void sumstat_complete();
      entry void pdfstat_complete();
      entry void com_complete();
    }

  } // inciter::

}
