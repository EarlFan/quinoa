namespace inciter {
/*!
  \page      inciter_newscheme How to add a new scheme to Inciter

@ref inciter_main supports multiple discretization schemes. This page describes
how to add yours by walking through an example of adding a new one.

@tableofcontents{xml}

@section inciter_newscheme_rationale Rationale and plan

Similar to the existing discretization schemes, `DiagCG`, `MatCG`, or `DG`, the
new scheme, `ALECG` (short for arbitrary Lagrangian-Eulerian continuous
Galerkin), will interact with `Discretization` in a child-base fashion, e.g.,
will directly access (and reuse) its member data and functions.  It will also
intereact with `Refiner`, for mesh refinement, and will also be migratable to
enable dynamic load balancing. In essence, it will have everything an existing
scheme has. However, we will _not_ implement the low-level details of the actual
numerical method, only the glue-code necessary to interact with the rest of the
code and we make it ready to start implementing the low-level details of a
particular discretization, done by a `PDE` class, held behind a derived class
of, e.g., `CGPDE` or `DGPDE`. For more details on how these classes interact,
see also the @ref inciter_design page.

@section inciter_newscheme_keyword 1. Add a new keyword

A specific discretization scheme is selected by the user in the control (input)
file via the `scheme` keyword, e.g., `scheme diagcg`. We add the new keyword,
`alecg`, which then can be recognized by the control file parser, in
`src/Control/Keywords.h` by adding the following code block:

@subsection inciter_newscheme_keyword_Keywords Control/Keywords.h

@code{.diff}
$ git diff src/Control/Keywords.h
diff --git a/src/Control/Keywords.h b/src/Control/Keywords.h
index 002869cb..c18f193a 100644
--- a/src/Control/Keywords.h
+++ b/src/Control/Keywords.h
@@ -4607,6 +4607,19 @@ struct diagcg_info {
 };
 using diagcg = keyword< diagcg_info, TAOCPP_PEGTL_STRING("diagcg") >;

+struct alecg_info {
+  static std::string name() { return "ALE-CG with RK"; }
+  static std::string shortDescription() { return "Select continuous Galerkin "
+    "with ALE + Runge-Kutta"; }
+  static std::string longDescription() { return
+    R"(This keyword is used to select the continuous Galerkin finite element
+    scheme in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined
+    with Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h
+    for other valid options.)"; }
+};
+using alecg = keyword< alecg_info, TAOCPP_PEGTL_STRING("alecg") >;
+
 struct dg_info {
   static std::string name() { return "DG(P0) + RK"; }
   static std::string shortDescription() { return
@endcode

We also add the new keyword to inciter's grammar's keywords pool:

@subsection inciter_newscheme_keyword_InputDeck Control/Inciter/InputDeck/InputDeck.h

@code{.diff}
$ git diff src/Control/Inciter/InputDeck/InputDeck.h
diff --git a/src/Control/Inciter/InputDeck/InputDeck.h b/src/Control/Inciter/InputDeck/InputDeck.h
index 83572480..20ce8975 100644
--- a/src/Control/Inciter/InputDeck/InputDeck.h
+++ b/src/Control/Inciter/InputDeck/InputDeck.h
@@ -144,6 +144,7 @@ class InputDeck :
                                    kw::scheme,
                                    kw::matcg,
                                    kw::diagcg,
+                                   kw::alecg,
                                    kw::dg,
                                    kw::dgp1,
                                    kw::flux,
@endcode

This is required so that the compiler can generate a database containing the
help for all the keywords in the grammar understood by inciter's control file
parser. The above changes not only add the keyword but also some documentation
that gets displayed when passing the `-C` or `-H` command line arguments to the
inciter executable, so quick help is available at the user's fingertips:

@code{.ansi}
$ inciter -C
inciter Control File Keywords:
             advdiff     string Specify the advection + diffusion physics configuration for a PDE
           advection     string Specify the advection physics configuration for a PDE
               alecg            Select continuous Galerkin with ALE + Runge-Kutta
           algorithm     string Select mesh partitioning algorithm
               alpha       real Set PDE parameter(s) alpha
...
$ inciter -H alecg
inciter control file keyword 'alecg'

   Select continuous Galerkin with ALE + Runge-Kutta (RK)

   This keyword is used to select the continuous Galerkin finite element scheme
   in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined with
   Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h for other
   valid options.
@endcode

@section inciter_newscheme_option 2. Add new option switch

Next is to add a new state to the existing Scheme option switch. This is done
by extending the list of schemes in `src/Control/Inciter/Options/Scheme.h`:

@subsection inciter_newscheme_option_Scheme Control/Inciter/Options/Scheme.h

@code{.diff}
$ git diff src/Control/Inciter/Options/Scheme.h
diff --git a/src/Control/Inciter/Options/Scheme.h b/src/Control/Inciter/Options/Scheme.h
index 4c20df61..7b89a117 100644
--- a/src/Control/Inciter/Options/Scheme.h
+++ b/src/Control/Inciter/Options/Scheme.h
@@ -21,6 +21,7 @@ namespace ctr {
 //! Scheme types
 enum class SchemeType : uint8_t { MatCG
                                 , DiagCG
+                                , ALECG
                                 , DG
                                 , DGP1 };

@@ -38,6 +39,7 @@ class Scheme : public tk::Toggle< SchemeType > {
     //! Valid expected choices to make them also available at compile-time
     using keywords = brigand::list< kw::matcg
                                   , kw::diagcg
+                                  , kw::alecg
                                   , kw::dg
                                   , kw::dgp1
                                   >;
@@ -52,11 +54,13 @@ class Scheme : public tk::Toggle< SchemeType > {
         //! Enums -> names (if defined, policy codes, if not, name)
         { { SchemeType::MatCG, kw::matcg::name() },
           { SchemeType::DiagCG, kw::diagcg::name() },
+          { SchemeType::ALECG, kw::alecg::name() },
           { SchemeType::DG, kw::dg::name() },
           { SchemeType::DGP1, kw::dgp1::name() } },
         //! keywords -> Enums
         { { kw::matcg::string(), SchemeType::MatCG },
           { kw::diagcg::string(), SchemeType::DiagCG },
+          { kw::alecg::string(), SchemeType::ALECG },
           { kw::dg::string(), SchemeType::DG },
           { kw::dgp1::string(), SchemeType::DGP1 } } ) {}

@@ -64,7 +68,8 @@ class Scheme : public tk::Toggle< SchemeType > {
     //! \param[in] type Scheme type
     //! \return Centering for scheme type
     Centering centering( SchemeType type ) {
-      if (type == SchemeType::MatCG || type == SchemeType::DiagCG)
+      if (type == SchemeType::MatCG || type == SchemeType::DiagCG ||
+          type == SchemeType::ALECG )
         return Centering::NODE;
       else if (type == SchemeType::DG || type == SchemeType::DGP1)
         return Centering::ELEM;
@endcode

@section inciter_newscheme_proxy 3. Add new Charm++ chare proxy in Scheme

`Scheme` is a class that, together with its base, `SchemeBase`, implements
concept-based runtime polymorphism for migratable Charm++ chare arrays using
value semantics. Client code, e.g., `Transporter`, interacts with
`Discretization` and its children via a uniform interface provided by `Scheme`,
which dispatches entry method calls to the correct class instance, the base or
the child, and is capable of performing broadcasts as well as addressing a
particular chare array element. Read more details at src/Inciter/Scheme.h. To
teach it to dispatch to our new `ALECG` scheme, besides the existing ones, we
make the following changes:

@subsection inciter_newscheme_proxy_SchemeBase Inciter/SchemeBase.h

@code{.diff}
$ git diff src/Inciter/SchemeBase.h
diff --git a/src/Inciter/SchemeBase.h b/src/Inciter/SchemeBase.h
index 61510d01..dea3d78a 100644
--- a/src/Inciter/SchemeBase.h
+++ b/src/Inciter/SchemeBase.h
@@ -22,6 +22,7 @@

 #include "NoWarning/matcg.decl.h"
 #include "NoWarning/diagcg.decl.h"
+#include "NoWarning/alecg.decl.h"
 #include "NoWarning/distfct.decl.h"
 #include "NoWarning/dg.decl.h"
 #include "NoWarning/discretization.decl.h"
@@ -51,6 +52,8 @@ class SchemeBase {
       } else if (scheme == ctr::SchemeType::DiagCG) {
         proxy = static_cast< CProxy_DiagCG >( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
+      } else if (scheme == ctr::SchemeType::ALECG) {
+        proxy = static_cast< CProxy_ALECG >( CProxy_ALECG::ckNew(m_bound) );
       } else if (scheme == ctr::SchemeType::DG ||
                  scheme == ctr::SchemeType::DGP1) {
         proxy = static_cast< CProxy_DG >( CProxy_DG::ckNew(m_bound) );
@@ -75,11 +78,12 @@ class SchemeBase {
     const CkArrayOptions& arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
-    using Proxy = boost::variant< CProxy_MatCG, CProxy_DiagCG, CProxy_DG >;
+    using Proxy =
+      boost::variant< CProxy_MatCG, CProxy_DiagCG, CProxy_ALECG, CProxy_DG >;
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant< CProxy_MatCG::element_t, CProxy_DiagCG::element_t,
-                      CProxy_DG::element_t >;
+                      CProxy_ALECG::element_t, CProxy_DG::element_t >;

   protected:
     //! Variant storing one proxy to which this class is configured for
@endcode

@section inciter_newscheme_chare 4. Add new Charm++ chare array

Next is to add a new class, `ALECG`, which will serve as the glue between
`Transporter`, `Refiner`, and `CGPDE`. These classes, respectively, are the
driver, the mesh refiner, and the polymorphic vector of PDE discretization class
objects that hold the low-level details of the numerical implementation of
spatial discretizations, dispatching to multiple specific systems of equations,
e.g., `cg::Transport` or `cg::CompFlow`.

We create the following new files:

- Inciter/alecg.ci, Charm++ interface file for ALECG,
- NoWarning/alecg.decl.h and NoWarning/alecg.def.h, which help ignore compiler
  warnings in Charm++-generated code, and
- Inciter/ALECG.h and Inciter/ALECG.C, header and implementation of ALECG.

Before we discuss the details of the above new files, let's get a couple of
simple things out of the way. We also need to add the new include to `Refiner.h`
so, e.g., it can call back to ALECG::resize() after a mesh refinement step:

@subsection inciter_newscheme_chare_Refiner Inciter/Refiner.h

@code{.diff}
$ git diff src/Inciter/Refiner.h
diff --git a/src/Inciter/Refiner.h b/src/Inciter/Refiner.h
index dfcb1ffd..4fe743a4 100644
--- a/src/Inciter/Refiner.h
+++ b/src/Inciter/Refiner.h
@@ -29,6 +29,7 @@
 #include "SchemeBase.h"
 #include "MatCG.h"
 #include "DiagCG.h"
+#include "ALECG.h"
 #include "DG.h"

 #include "NoWarning/transporter.decl.h"
@endcode

We also tell the build system about our new `ALECG` class and its Charm++
module:

@subsection inciter_newscheme_chare_CMakeLists Inciter/CMakeLists.txt

@code{.diff}
$ gd src/Inciter/CMakeLists.txt
diff --git a/src/Inciter/CMakeLists.txt b/src/Inciter/CMakeLists.txt
index 141055ec..e339b65b 100644
--- a/src/Inciter/CMakeLists.txt
+++ b/src/Inciter/CMakeLists.txt
@@ -14,6 +14,7 @@ add_library(Inciter
             Sorter.C
             MatCG.C
             DiagCG.C
+            ALECG.C
             DG.C
             FluxCorrector.C
             DistFCT.C
@@ -74,6 +75,7 @@ addCharmModule( "refiner" "Inciter" )
 addCharmModule( "sorter" "Inciter" )
 addCharmModule( "matcg" "Inciter" )
 addCharmModule( "diagcg" "Inciter" )
+addCharmModule( "alecg" "Inciter" )
 addCharmModule( "distfct" "Inciter" )
 addCharmModule( "dg" "Inciter" )
@endcode

The `addCharmModule` cmake macro above, defined in `cmake/charm.cmake`, ensures
that build target `Inciter` will properly depend on our new `alecg` Charm++
module, defined in `Inciter/alecg.ci`. The macro also tells cmake how the two
files, `alecg.decl.h` and `alecg.def.h`, are generated from `alecg.ci`: using
`charmc`, a compiler wrapper that generates Charm++-code to make the `ALECG`
from an ordinary C++ class into a Charm++ chare array, with _entry_ methods
callable across the network, make it migratable, enable its structured DAGger,
etc. See also the Charm++ manual.

Now to the new files. First is the new Charm++ interface file, Inciter/alecg.ci:

@subsection inciter_newscheme_chare_alecg Inciter/alecg.ci

@include Inciter/alecg.ci

@subsection inciter_newscheme_chare_NoWarning NoWarning/alecg.decl.h and NoWarning/alecg.def.h

The newly added files to the `NoWarning/` directory simply include the
Charm++-generated `alecg.decl.h` and `alecg.def.h` files and locally, around
the include, turn off specific compiler warnings for various compilers -- we
will not discuss them here further.

Next are the newly added Inciter/ALECG.h and Inciter/ALECG.C, header and
implementation of ALECG.

@subsection inciter_newscheme_chare_ALECG_h Inciter/ALECG.h

@include Inciter/ALECG.h

@subsection inciter_newscheme_chare_ALECG_C Inciter/ALECG.C

@include Inciter/ALECG.C

@subsection inciter_newscheme_chare_inciter Main/inciter.ci

@code{.diff}
$ git diff src/Main/inciter.ci
diff --git a/src/Main/inciter.ci b/src/Main/inciter.ci
index bf7eac98..e9b114b6 100644
--- a/src/Main/inciter.ci
+++ b/src/Main/inciter.ci
@@ -14,6 +14,7 @@ mainmodule inciter {
   extern module partitioner;
   extern module matcg;
   extern module diagcg;
+  extern module alecg;
   extern module dg;
   extern module charestatecollector;
@endcode

@subsection inciter_newscheme_chare_PDEStack PDE/PDEStack.C

@code{.diff}
$ git diff src/PDE/PDEStack.C
diff --git a/src/PDE/PDEStack.C b/src/PDE/PDEStack.C
index 438cb5e3..9b2e14e7 100644
--- a/src/PDE/PDEStack.C
+++ b/src/PDE/PDEStack.C
@@ -108,7 +108,9 @@ PDEStack::selectedCG() const
   std::vector< CGPDE > pdes;                // will store instantiated PDEs

   const auto sch = g_inputdeck.get< tag::discr, tag::scheme >();
-  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG) {
+  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG ||
+      sch == ctr::SchemeType::ALECG)
+  {

     for (const auto& d : g_inputdeck.get< tag::selected, tag::pde >()) {
       if (d == ctr::PDEType::TRANSPORT)
@endcode

*/
} // inciter::
