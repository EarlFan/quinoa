namespace inciter {
/*!
  \page      inciter_newscheme How to add a new scheme to Inciter

@ref inciter_main supports multiple discretization schemes. This page describes
how to add yours by walking through an example of adding a new one.

@tableofcontents{xml}

@section inciter_newscheme_rationale Rationale and plan

Similar to the existing discretization schemes, `DiagCG`, `MatCG`, or `DG`, the
new scheme, `ALECG` (short for arbitrary Lagrangian-Eulerian continuous
Galerkin), will interact with `Discretization` in a child-base fashion, e.g.,
will directly access (and reuse) its member data and functions.  It will also
intereact with `Refiner`, for mesh refinement, and will also be migratable to
enable dynamic load balancing. In essence, it will have everything an existing
scheme has. However, we will _not_ implement the low-level details of the actual
numerical method, only the glue-code necessary to interact with the rest of the
code and we make it ready to start implementing the low-level details of a
particular discretization, done by a `PDE` class, held behind a derived class
of, e.g., `CGPDE` or `DGPDE`. For more details on how these classes interact,
see also the @ref inciter_design page.

@section inciter_newscheme_keyword 1. Add a new keyword

A specific discretization scheme is selected by the user in the control (input)
file via the `scheme` keyword, e.g., `scheme diagcg`. We add the new keyword,
`alecg`, which then can be recognized by the control file parser, in
`src/Control/Keywords.h` by adding the following code block:

@subsection inciter_newscheme_keyword_Keywords Control/Keywords.h

@code{.diff}
$ git diff src/Control/Keywords.h
diff --git a/src/Control/Keywords.h b/src/Control/Keywords.h
index 002869cb..c18f193a 100644
--- a/src/Control/Keywords.h
+++ b/src/Control/Keywords.h
@@ -4607,6 +4607,19 @@ struct diagcg_info {
 };
 using diagcg = keyword< diagcg_info, TAOCPP_PEGTL_STRING("diagcg") >;

+struct alecg_info {
+  static std::string name() { return "ALE-CG with RK"; }
+  static std::string shortDescription() { return "Select continuous Galerkin "
+    "with ALE + Runge-Kutta"; }
+  static std::string longDescription() { return
+    R"(This keyword is used to select the continuous Galerkin finite element
+    scheme in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined
+    with Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h
+    for other valid options.)"; }
+};
+using alecg = keyword< alecg_info, TAOCPP_PEGTL_STRING("alecg") >;
+
 struct dg_info {
   static std::string name() { return "DG(P0) + RK"; }
   static std::string shortDescription() { return
@endcode

We also add the new keyword to inciter's grammar's keywords pool:

@subsection inciter_newscheme_keyword_InputDeck Control/Inciter/InputDeck/InputDeck.h

@code{.diff}
$ git diff src/Control/Inciter/InputDeck/InputDeck.h
diff --git a/src/Control/Inciter/InputDeck/InputDeck.h b/src/Control/Inciter/InputDeck/InputDeck.h
index 83572480..20ce8975 100644
--- a/src/Control/Inciter/InputDeck/InputDeck.h
+++ b/src/Control/Inciter/InputDeck/InputDeck.h
@@ -144,6 +144,7 @@ class InputDeck :
                                    kw::scheme,
                                    kw::matcg,
                                    kw::diagcg,
+                                   kw::alecg,
                                    kw::dg,
                                    kw::dgp1,
                                    kw::flux,
@endcode

This is required so that the compiler can generate a database containing the
help for all the keywords in the grammar understood by inciter's control file
parser. The above changes not only add the keyword but also some documentation
that gets displayed when passing the `-C` or `-H` command line arguments to the
inciter executable, so quick help is available at the user's fingertips:

@code{.ansi}
$ inciter -C
inciter Control File Keywords:
             advdiff     string Specify the advection + diffusion physics configuration for a PDE
           advection     string Specify the advection physics configuration for a PDE
               alecg            Select continuous Galerkin with ALE + Runge-Kutta
           algorithm     string Select mesh partitioning algorithm
               alpha       real Set PDE parameter(s) alpha
...
$ inciter -H alecg
inciter control file keyword 'alecg'

   Select continuous Galerkin with ALE + Runge-Kutta (RK)

   This keyword is used to select the continuous Galerkin finite element scheme
   in the arbitrary Lagrangian-Eulerian (ALE) reference frame combined with
   Runge-Kutta (RK) time stepping. See Control/Inciter/Options/Scheme.h for other
   valid options.
@endcode

@section inciter_newscheme_option 2. Add new option switch

Next is to add a new state to the existing Scheme option switch. This is done
by extending the list of schemes in `src/Control/Inciter/Options/Scheme.h`:

@subsection inciter_newscheme_option_Scheme Control/Inciter/Options/Scheme.h

@code{.diff}
$ git diff src/Control/Inciter/Options/Scheme.h
diff --git a/src/Control/Inciter/Options/Scheme.h b/src/Control/Inciter/Options/Scheme.h
index 4c20df61..7b89a117 100644
--- a/src/Control/Inciter/Options/Scheme.h
+++ b/src/Control/Inciter/Options/Scheme.h
@@ -21,6 +21,7 @@ namespace ctr {
 //! Scheme types
 enum class SchemeType : uint8_t { MatCG
                                 , DiagCG
+                                , ALECG
                                 , DG
                                 , DGP1 };

@@ -38,6 +39,7 @@ class Scheme : public tk::Toggle< SchemeType > {
     //! Valid expected choices to make them also available at compile-time
     using keywords = brigand::list< kw::matcg
                                   , kw::diagcg
+                                  , kw::alecg
                                   , kw::dg
                                   , kw::dgp1
                                   >;
@@ -52,11 +54,13 @@ class Scheme : public tk::Toggle< SchemeType > {
         //! Enums -> names (if defined, policy codes, if not, name)
         { { SchemeType::MatCG, kw::matcg::name() },
           { SchemeType::DiagCG, kw::diagcg::name() },
+          { SchemeType::ALECG, kw::alecg::name() },
           { SchemeType::DG, kw::dg::name() },
           { SchemeType::DGP1, kw::dgp1::name() } },
         //! keywords -> Enums
         { { kw::matcg::string(), SchemeType::MatCG },
           { kw::diagcg::string(), SchemeType::DiagCG },
+          { kw::alecg::string(), SchemeType::ALECG },
           { kw::dg::string(), SchemeType::DG },
           { kw::dgp1::string(), SchemeType::DGP1 } } ) {}

@@ -64,7 +68,8 @@ class Scheme : public tk::Toggle< SchemeType > {
     //! \param[in] type Scheme type
     //! \return Centering for scheme type
     Centering centering( SchemeType type ) {
-      if (type == SchemeType::MatCG || type == SchemeType::DiagCG)
+      if (type == SchemeType::MatCG || type == SchemeType::DiagCG ||
+          type == SchemeType::ALECG )
         return Centering::NODE;
       else if (type == SchemeType::DG || type == SchemeType::DGP1)
         return Centering::ELEM;
@endcode

@section inciter_newscheme_proxy 3. Add new Charm++ chare proxy in Scheme

`Scheme` is a class that, together with its base, `SchemeBase`, implements
concept-based runtime polymorphism for migratable Charm++ chare arrays using
value semantics. Client code, e.g., `Transporter`, interacts with
`Discretization` and its children via a uniform interface provided by `Scheme`,
which dispatches entry method calls to the correct class instance, the base or
the child, and is capable of performing broadcasts as well as addressing a
particular chare array element. Read more details at src/Inciter/Scheme.h. To
teach it to dispatch to our new `ALECG` scheme, besides the existing ones, we
make the following changes:

@subsection inciter_newscheme_proxy_SchemeBase Inciter/SchemeBase.h

@code{.diff}
$ git diff src/Inciter/SchemeBase.h
diff --git a/src/Inciter/SchemeBase.h b/src/Inciter/SchemeBase.h
index 61510d01..dea3d78a 100644
--- a/src/Inciter/SchemeBase.h
+++ b/src/Inciter/SchemeBase.h
@@ -22,6 +22,7 @@

 #include "NoWarning/matcg.decl.h"
 #include "NoWarning/diagcg.decl.h"
+#include "NoWarning/alecg.decl.h"
 #include "NoWarning/distfct.decl.h"
 #include "NoWarning/dg.decl.h"
 #include "NoWarning/discretization.decl.h"
@@ -51,6 +52,8 @@ class SchemeBase {
       } else if (scheme == ctr::SchemeType::DiagCG) {
         proxy = static_cast< CProxy_DiagCG >( CProxy_DiagCG::ckNew(m_bound) );
         fctproxy= CProxy_DistFCT::ckNew(m_bound);
+      } else if (scheme == ctr::SchemeType::ALECG) {
+        proxy = static_cast< CProxy_ALECG >( CProxy_ALECG::ckNew(m_bound) );
       } else if (scheme == ctr::SchemeType::DG ||
                  scheme == ctr::SchemeType::DGP1) {
         proxy = static_cast< CProxy_DG >( CProxy_DG::ckNew(m_bound) );
@@ -75,11 +78,12 @@ class SchemeBase {
     const CkArrayOptions& arrayoptions() { return m_bound; }

     //! Variant type listing all chare proxy types modeling the same concept
-    using Proxy = boost::variant< CProxy_MatCG, CProxy_DiagCG, CProxy_DG >;
+    using Proxy =
+      boost::variant< CProxy_MatCG, CProxy_DiagCG, CProxy_ALECG, CProxy_DG >;
     //! Variant type listing all chare element proxy types (behind operator[])
     using ProxyElem =
       boost::variant< CProxy_MatCG::element_t, CProxy_DiagCG::element_t,
-                      CProxy_DG::element_t >;
+                      CProxy_ALECG::element_t, CProxy_DG::element_t >;

   protected:
     //! Variant storing one proxy to which this class is configured for
@endcode

@section inciter_newscheme_chare 4. Add new Charm++ chare array

Next is to add a new class, `ALECG`, that will serve as the glue between
`Transporter`, `Refiner`, and `CGPDE`. These classes, respectively, are the
driver, the mesh refiner, and the polymorphic vector of PDE discretization
class objects that hold the low-level details of the numerical implementation
of spatial discretizations, dispatching to multiple specific systems of
equations, e.g., `cg::Transport` or `cg::CompFlow`.

We create the following new files:

- Inciter/alecg.ci, Charm++ interface file for ALECG,
- NoWarning/alecg.decl.h and NoWarning/alecg.def.h, which help ignore compiler
  warnings in Charm++-generated code, and
- Inciter/ALECG.h and Inciter/ALECG.C, header and implementation of ALECG.

Before we discuss the details of the above new files, let's get a couple of
simple things out of the way. We also need to dd the new include to `Refiner.h`
so it can call back to ALECG::resize() after a mesh refinement step:

@subsection inciter_newscheme_chare_Refiner Inciter/Refiner.h

@code{.diff}
$ git diff src/Inciter/Refiner.h
diff --git a/src/Inciter/Refiner.h b/src/Inciter/Refiner.h
index dfcb1ffd..4fe743a4 100644
--- a/src/Inciter/Refiner.h
+++ b/src/Inciter/Refiner.h
@@ -29,6 +29,7 @@
 #include "SchemeBase.h"
 #include "MatCG.h"
 #include "DiagCG.h"
+#include "ALECG.h"
 #include "DG.h"

 #include "NoWarning/transporter.decl.h"
@endcode

We also tell the build system about our new `ALECG` class and its Charm++
module:

@subsection inciter_newscheme_chare_CMakeLists Inciter/CMakeLists.txt

@code{.diff}
$ gd src/Inciter/CMakeLists.txt
diff --git a/src/Inciter/CMakeLists.txt b/src/Inciter/CMakeLists.txt
index 141055ec..e339b65b 100644
--- a/src/Inciter/CMakeLists.txt
+++ b/src/Inciter/CMakeLists.txt
@@ -14,6 +14,7 @@ add_library(Inciter
             Sorter.C
             MatCG.C
             DiagCG.C
+            ALECG.C
             DG.C
             FluxCorrector.C
             DistFCT.C
@@ -74,6 +75,7 @@ addCharmModule( "refiner" "Inciter" )
 addCharmModule( "sorter" "Inciter" )
 addCharmModule( "matcg" "Inciter" )
 addCharmModule( "diagcg" "Inciter" )
+addCharmModule( "alecg" "Inciter" )
 addCharmModule( "distfct" "Inciter" )
 addCharmModule( "dg" "Inciter" )
@endcode

The `addCharmModule` cmake macro above ensures that build target `Inciter` will
properly depend on our new `alecg` Charm++ module, defined in
`Inciter/alecg.ci`.

Now to the new files. First is the new Charm++ interface file, Inciter/alecg.ci:

@subsection inciter_newscheme_chare_alecg Inciter/alecg.ci

@code{.cpp}
// *****************************************************************************
/*!
  \file      src/Inciter/alecg.ci
  \copyright 2016-2018, Los Alamos National Security, LLC.
  \brief     Charm++ module interface for continuous Galerkin + ALE + RK
  \details   Charm++ module interface file for the continuous Galerkin (CG)
             finite element scheme in the arbitrary Lagrangian-Eulerian (ALE)
             reference frame + Runge-Kutta (RK) time stepping.
  \see       ALECG.h and ALECG.C for more info.
\*\/
// *****************************************************************************

module alecg {

  extern module transporter;
  extern module discretization;

  include "UnsMesh.h";
  include "PUPUtil.h";
  include "FaceData.h";

  namespace inciter {

    array [1D] ALECG {
      entry ALECG( const CProxy_Discretization& disc,
                   const tk::CProxy_Solver& solver,
                   const FaceData& fd );
      initnode void registerReducers();
      entry void setup( tk::real v );
      entry void dt();
      entry void diag();
      entry [reductiontarget] void advance( tk::real newdt );
      entry void comlhs( const std::vector< std::size_t >& gid,
                         const std::vector< std::vector< tk::real > >& L );
      entry void comrhs( const std::vector< std::size_t >& gid,
                         const std::vector< std::vector< tk::real > >& R );
      entry void resized();
      entry void lhs();

      // SDAG code follows. See http://charm.cs.illinois.edu/manuals/html/
      // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".

      entry void wait4lhs() {
        when ownlhs_complete(), comlhs_complete() serial "lhs" { lhsdone(); } };

      entry void wait4rhs() {
        when ownrhs_complete(), comrhs_complete() serial "rhs" { solve(); } };

      entry void wait4eval() {
        when diag_complete(), ref_complete(), lhs_complete(),
             resize_complete() serial "eval" { eval(); } };

      entry void ownlhs_complete();
      entry void ownrhs_complete();
      entry void comlhs_complete();
      entry void comrhs_complete();
      entry void diag_complete();
      entry void ref_complete();
      entry void lhs_complete();
      entry void resize_complete();
    };

  } // inciter::

}
@endcode

@subsection inciter_newscheme_chare_NoWarning NoWarning/alecg.decl.h, NoWarning/alecg.def.h

The newly added files to the `NoWarning/` directory simply include the
Charm++-generated `alecg.decl.h` and `alecg.def.h` files and locally, around
the include, turn off specific compiler warnings for various compilers -- we
will not discuss them here further.

Next are the newly added Inciter/ALECG.h and Inciter/ALECG.C, header and
implementation of ALECG.

@subsection inciter_newscheme_chare_ALECG_h Inciter/ALECG.h

@code{.cpp}
// *****************************************************************************
/*!
  \file      src/Inciter/ALECG.h
  \copyright 2016-2018, Los Alamos National Security, LLC.
  \brief     ALECG for a PDE system with continuous Galerkin + ALE + RK
  \details   ALECG advances a system of partial differential equations (PDEs)
    using a continuous Galerkin (CG) finite element (FE) spatial discretization
    (using linear shapefunctions on tetrahedron elements) combined with a
    Runge-Kutta (RK) time stepping scheme in the argbitrary Eulerian-Lagrangian
    reference frame.

    There are a potentially large number of ALECG Charm++ chares created by
    Transporter. Each ALECG gets a chunk of the full load (part of the mesh)
    and does the same: initializes and advances a number of PDE systems in time.

    The implementation uses the Charm++ runtime system and is fully
    asynchronous, overlapping computation and communication. The algorithm
    utilizes the structured dagger (SDAG) Charm++ functionality. The high-level
    overview of the algorithm structure and how it interfaces with Charm++ is
    discussed in the Charm++ interface file src/Inciter/alecg.ci.
\*\/
// *****************************************************************************
#ifndef ALECG_h
#define ALECG_h

#include <vector>
#include <map>

#include "QuinoaConfig.h"
#include "Types.h"
#include "Fields.h"
#include "DerivedData.h"
#include "VectorReducer.h"
#include "FluxCorrector.h"
#include "NodeDiagnostics.h"
#include "Inciter/InputDeck/InputDeck.h"
#include "FaceData.h"

#include "NoWarning/alecg.decl.h"

namespace inciter {

extern ctr::InputDeck g_inputdeck;

//! ALECG Charm++ chare array used to advance PDEs in time with ALECG+RK
class ALECG : public CBase_ALECG {

  public:
    #if defined(__clang__)
      #pragma clang diagnostic push
      #pragma clang diagnostic ignored "-Wunused-parameter"
      #pragma clang diagnostic ignored "-Wdeprecated-declarations"
    #elif defined(STRICT_GNUC)
      #pragma GCC diagnostic push
      #pragma GCC diagnostic ignored "-Wunused-parameter"
      #pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    #elif defined(__INTEL_COMPILER)
      #pragma warning( push )
      #pragma warning( disable: 1478 )
    #endif
    // Include Charm++ SDAG code. See http://charm.cs.illinois.edu/manuals/html/
    // charm++/manual.html, Sec. "Structured Control Flow: Structured Dagger".
    ALECG_SDAG_CODE
    #if defined(__clang__)
      #pragma clang diagnostic pop
    #elif defined(STRICT_GNUC)
      #pragma GCC diagnostic pop
    #elif defined(__INTEL_COMPILER)
      #pragma warning( pop )
    #endif

    //! Constructor
    explicit ALECG( const CProxy_Discretization& disc,
                    const tk::CProxy_Solver& solver,
                    const FaceData& fd );

    #if defined(__clang__)
      #pragma clang diagnostic push
      #pragma clang diagnostic ignored "-Wundefined-func-template"
    #endif
    //! Migrate constructor
    explicit ALECG( CkMigrateMessage* ) {}
    #if defined(__clang__)
      #pragma clang diagnostic pop
    #endif

    //! Configure Charm++ custom reduction types initiated from this chare array
    static void registerReducers();

    //! Setup: query boundary conditions, output mesh, etc.
    void setup( tk::real v );

    //! Compute time step size
    void dt();

    //! Advance equations to next time step
    void advance( tk::real newdt );

    //! Compute left-hand side of transport equations
    void lhs();

    //! Receive contributions to left-hand side matrix on chare-boundaries
    void comlhs( const std::vector< std::size_t >& gid,
                 const std::vector< std::vector< tk::real > >& L );

    //! Receive contributions to right-hand side vector on chare-boundaries
    void comrhs( const std::vector< std::size_t >& gid,
                 const std::vector< std::vector< tk::real > >& R );

    //! Update solution at the end of time step
    void update( const tk::Fields& a );

    //! Signal the runtime system that diagnostics have been computed
    void diag();

    //! Optionally refine/derefine mesh
    void refine();

    //! Receive new mesh from refiner
    void resize( const tk::UnsMesh::Chunk& chunk,
                 const tk::UnsMesh::Coords& coord,
                 const tk::Fields& u,
                 const std::unordered_map< int,
                         std::vector< std::size_t > >& msum,
                 const std::map< int, std::vector< std::size_t > >& bnode );

    //! Const-ref access to current solution
    //! \param[in,out] u Reference to update with current solution
    void solution( tk::Fields& u ) const { u = m_u; }

    //! Resizing data sutrctures after mesh refinement has been completed
    void resized();

    /** @name Charm++ pack/unpack serializer member functions \*\/
    ///@{
    //! \brief Pack/Unpack serialize member function
    //! \param[in,out] p Charm++'s PUP::er serializer object reference
    void pup( PUP::er &p ) override {
      p | m_disc;
      p | m_itf;
      p | m_initial;
      p | m_nsol;
      p | m_nlhs;
      p | m_nrhs;
      p | m_fd;
      p | m_u;
      p | m_du;
      p | m_lhs;
      p | m_rhs;
      p | m_lhsc;
      p | m_rhsc;
      p | m_vol;
      p | m_diag;
    }
    //! \brief Pack/Unpack serialize operator|
    //! \param[in,out] p Charm++'s PUP::er serializer object reference
    //! \param[in,out] i ALECG object reference
    friend void operator|( PUP::er& p, ALECG& i ) { i.pup(p); }
    //@}

  private:
    using ncomp_t = kw::ncomp::info::expect::type;

    //! Discretization proxy
    CProxy_Discretization m_disc;
    //! Field output iteration count without mesh refinement
    //! \details Counts the number of field outputs to file during two
    //!   time steps with mesh efinement
    uint64_t m_itf;
    //! True if starting time stepping, false if during time stepping
    bool m_initial;
    //! Counter for high order solution vector nodes updated
    std::size_t m_nsol;
    //! Counter for left-hand side matrix (vector) nodes updated
    std::size_t m_nlhs;
    //! Counter for right-hand side vector nodes updated
    std::size_t m_nrhs;
    //! Face data
    FaceData m_fd;
    //! Unknown/solution vector at mesh nodes
    tk::Fields m_u;
    //! Unknown/solution vector increment (high order)
    tk::Fields m_du;
    //! Lumped lhs mass matrix
    tk::Fields m_lhs;
    //! Right-hand side vector (for the high order system)
    tk::Fields m_rhs;
    //! Receive buffers for communication
    std::vector< std::vector< tk::real > > m_lhsc, m_rhsc;
    //! Total mesh volume
    tk::real m_vol;
    //! Diagnostics object
    NodeDiagnostics m_diag;

    //! Access bound Discretization class pointer
    Discretization* Disc() const {
      Assert( m_disc[ thisIndex ].ckLocal() != nullptr, "ckLocal() null" );
      return m_disc[ thisIndex ].ckLocal();
    }

    //! Size communication buffers
    void resizeComm();

    //! Output mesh and particle fields to files
    void out();

    //! Output mesh-based fields to file
    void writeFields( tk::real time );

    //! The own and communication portion of the left-hand side is complete
    void lhsdone();

    //! Combine own and communicated contributions to left hand side
    void lhsmerge();

    //! Compute righ-hand side vector of transport equations
    void rhs();

    //! Start time stepping
    void start();

    //! Solve low and high order diagonal systems
    void solve();

    //! Evaluate whether to continue with next step
    void eval();
};

} // inciter::

#endif // ALECG_h
@endcode

@subsection inciter_newscheme_chare_ALECG_C Inciter/ALECG.C

@code{.cpp}
// *****************************************************************************
/*!
  \file      src/Inciter/ALECG.C
  \copyright 2016-2018, Los Alamos National Security, LLC.
  \brief     ALECG for a PDE system with continuous Galerkin + ALE + RK
  \details   ALECG advances a system of partial differential equations (PDEs)
    using a continuous Galerkin (CG) finite element (FE) spatial discretization
    (using linear shapefunctions on tetrahedron elements) combined with a
    Runge-Kutta (RK) time stepping scheme in the argbitrary Eulerian-Lagrangian
    reference frame.
  \see The documentation in ALECG.h.
\*\/
// *****************************************************************************

#include "QuinoaConfig.h"
#include "ALECG.h"
#include "Solver.h"
#include "Vector.h"
#include "Reader.h"
#include "ContainerUtil.h"
#include "UnsMesh.h"
#include "ExodusIIMeshWriter.h"
#include "Inciter/InputDeck/InputDeck.h"
#include "DerivedData.h"
#include "CGPDE.h"
#include "Discretization.h"
#include "DiagReducer.h"
#include "NodeBC.h"
#include "Refiner.h"

#ifdef HAS_ROOT
  #include "RootMeshWriter.h"
#endif

namespace inciter {

extern ctr::InputDeck g_inputdeck;
extern ctr::InputDeck g_inputdeck_defaults;
extern std::vector< CGPDE > g_cgpde;

} // inciter::

// extern tk::CProxy_ChareStateCollector stateProxy;

using inciter::ALECG;

ALECG::ALECG( const CProxy_Discretization& disc,
              const tk::CProxy_Solver& solver,
              const FaceData& fd ) :
  m_disc( disc ),
  m_itf( 0 ),
  m_initial( true ),
  m_nsol( 0 ),
  m_nlhs( 0 ),
  m_nrhs( 0 ),
  m_fd( fd ),
  m_u( m_disc[thisIndex].ckLocal()->Gid().size(),
       g_inputdeck.get< tag::component >().nprop() ),
  m_du( m_u.nunk(), m_u.nprop() ),
  m_lhs( m_u.nunk(), m_u.nprop() ),
  m_rhs( m_u.nunk(), m_u.nprop() ),
  m_lhsc(),
  m_rhsc(),
  m_vol( 0.0 ),
  m_diag()
// *****************************************************************************
//  Constructor
//! \param[in] disc Discretization proxy
//! \param[in] solver Linear system solver (Solver) proxy
//! \param[in] fd Face data structures
// *****************************************************************************
{
  // Enable migration at AtSync
  usesAtSync = true;

  // Size communication buffers
  resizeComm();

  // Signal the runtime system that the workers have been created
  solver.ckLocalBranch()->created();
}

void
ALECG::resizeComm()
// *****************************************************************************
//  Size communication buffers
//! \details The size of the communication buffers are determined based on
//!    Disc()->Bid.size() and m_u.nprop().
// *****************************************************************************
{
  auto d = Disc();

  auto np = m_u.nprop();
  auto nb = d->Bid().size();
  m_lhsc.resize( nb );
  for (auto& b : m_lhsc) b.resize( np );
  m_rhsc.resize( nb );
  for (auto& b : m_rhsc) b.resize( np );

  // Zero communication buffers
  for (auto& b : m_lhsc) std::fill( begin(b), end(b), 0.0 );
}

void
ALECG::registerReducers()
// *****************************************************************************
//  Configure Charm++ reduction types initiated from this chare array
//! \details Since this is a [nodeinit] routine, the runtime system executes the
//!   routine exactly once on every logical node early on in the Charm++ init
//!   sequence. Must be static as it is called without an object. See also:
//!   Section "Initializations at Program Startup" at in the Charm++ manual
//!   http://charm.cs.illinois.edu/manuals/html/charm++/manual.html.
// *****************************************************************************
{
  NodeDiagnostics::registerReducers();
}

void
ALECG::setup( tk::real v )
// *****************************************************************************
// Setup rows, query boundary conditions, output mesh, etc.
//! \param[in] v Total mesh volume
// *****************************************************************************
{
  auto d = Disc();

  // Store total mesh volume
  m_vol = v;

  // Activate SDAG waits for computing the left-hand side
  thisProxy[ thisIndex ].wait4lhs();

  // Compute left-hand side of PDEs
  lhs();

  // Set initial conditions for all PDEs
  for (const auto& eq : g_cgpde) eq.initialize( d->Coord(), m_u, d->T() );

  // Output initial condition to file (if not in benchmark mode)
  if ( !g_inputdeck.get< tag::cmd, tag::benchmark >() ) {
    // Output chare mesh to file
    d->writeMesh( m_fd.Bface(), m_fd.Triinpoel(), m_fd.Bnode());
    // Output fields metadata to output file
    d->writeNodeMeta();
    // Output initial conditions to file (regardless of whether it was requested)
    writeFields( d->T() );
  }
}

void
ALECG::lhsdone()
// *****************************************************************************
// The own and communication portion of the left-hand side is complete
// *****************************************************************************
{
  if (m_initial) {
    start();
  } else {
    lhsmerge();
    lhs_complete();
  }
}

void
ALECG::lhsmerge()
// *****************************************************************************
//  Combine own and communicated contributions to left hand side
// *****************************************************************************
{
}

void
ALECG::resized()
// *****************************************************************************
// Resizing data sutrctures after mesh refinement has been completed
// *****************************************************************************
{
  resize_complete();
}

void
ALECG::start()
// *****************************************************************************
//  Start time stepping
// *****************************************************************************
{
  // Start timer measuring time stepping wall clock time
  Disc()->Timer().zero();

  // Combine own and communicated contributions to left hand side
  lhsmerge();

  // Start time stepping by computing the size of the next time step)
  dt();
}

void
ALECG::lhs()
// *****************************************************************************
// Compute the left-hand side of transport equations
// *****************************************************************************
{
  auto d = Disc();

  // Compute own portion of the lhs
  // ...

  // Communicate lhs to other chares on chare-boundary
  if (d->Msum().empty())        // in serial we are done
    comlhs_complete();
  else // send contributions of lhs to chare-boundary nodes to fellow chares
    for (const auto& n : d->Msum()) {
      std::vector< std::vector< tk::real > > l;
      for (auto i : n.second) l.push_back( m_lhs[ tk::cref_find(d->Lid(),i) ] );
      thisProxy[ n.first ].comlhs( n.second, l );
    }

  ownlhs_complete();
}

void
ALECG::comlhs( const std::vector< std::size_t >& gid,
                const std::vector< std::vector< tk::real > >& L )
// *****************************************************************************
//  Receive contributions to left-hand side diagonal matrix on chare-boundaries
//! \param[in] gid Global mesh node IDs at which we receive LHS contributions
//! \param[in] L Partial contributions of LHS to chare-boundary nodes
//! \details This function receives contributions to m_lhs, which stores the
//!   diagonal (lumped) mass matrix at mesh nodes. While m_lhs stores
//!   own contributions, m_lhsc collects the neighbor chare contributions during
//!   communication. This way work on m_lhs and m_lhsc is overlapped. The two
//!   are combined in start().
// *****************************************************************************
{
  Assert( L.size() == gid.size(), "Size mismatch" );

  using tk::operator+=;

  auto d = Disc();

  for (std::size_t i=0; i<gid.size(); ++i) {
    auto bid = tk::cref_find( d->Bid(), gid[i] );
    Assert( bid < m_lhsc.size(), "Indexing out of bounds" );
    m_lhsc[ bid ] += L[i];
  }

  // When we have heard from all chares we communicate with, this chare is done
  if (++m_nlhs == d->Msum().size()) {
    m_nlhs = 0;
    comlhs_complete();
  }
}

void
ALECG::dt()
// *****************************************************************************
// Comppute time step size
// *****************************************************************************
{
  tk::real mindt = std::numeric_limits< tk::real >::max();

  auto const_dt = g_inputdeck.get< tag::discr, tag::dt >();
  auto def_const_dt = g_inputdeck_defaults.get< tag::discr, tag::dt >();
  auto eps = std::numeric_limits< tk::real >::epsilon();

  auto d = Disc();

  // use constant dt if configured
  if (std::abs(const_dt - def_const_dt) > eps) {

    mindt = const_dt;

  } else {      // compute dt based on CFL

    // find the minimum dt across all PDEs integrated
    for (const auto& eq : g_cgpde) {
      auto eqdt = eq.dt( d->Coord(), d->Inpoel(), m_u );
      if (eqdt < mindt) mindt = eqdt;
    }

    // Scale smallest dt with CFL coefficient
    mindt *= g_inputdeck.get< tag::discr, tag::cfl >();

  }

  // Actiavate SDAG waits for time step
  thisProxy[ thisIndex ].wait4rhs();
  thisProxy[ thisIndex ].wait4eval();

  // Contribute to minimum dt across all chares the advance to next step
  contribute( sizeof(tk::real), &mindt, CkReduction::min_double,
              CkCallback(CkReductionTarget(Transporter,advance), d->Tr()) );
}

void
ALECG::rhs()
// *****************************************************************************
// Compute right-hand side of transport equations
// *****************************************************************************
{
  auto d = Disc();

  // Compute own portion of the right-hand side
  // ...

  // Communicate rhs to other chares on chare-boundary
  if (d->Msum().empty())        // in serial we are done
    comrhs_complete();
  else // send contributions of rhs to chare-boundary nodes to fellow chares
    for (const auto& n : d->Msum()) {
      std::vector< std::vector< tk::real > > r;
      for (auto i : n.second) r.push_back( m_rhs[ tk::cref_find(d->Lid(),i) ] );
      thisProxy[ n.first ].comrhs( n.second, r );
    }

  ownrhs_complete();
}

void
ALECG::comrhs( const std::vector< std::size_t >& gid,
                const std::vector< std::vector< tk::real > >& R )
// *****************************************************************************
//  Receive contributions to right-hand side vector on chare-boundaries
//! \param[in] gid Global mesh node IDs at which we receive RHS contributions
//! \param[in] R Partial contributions of RHS to chare-boundary nodes
//! \details This function receives contributions to m_rhs, which stores the
//!   right hand side vector at mesh nodes. While m_rhs stores own
//!   contributions, m_rhsc collects the neighbor chare contributions during
//!   communication. This way work on m_rhs and m_rhsc is overlapped. The two
//!   are combined in solve().
// *****************************************************************************
{
  Assert( R.size() == gid.size(), "Size mismatch" );

  using tk::operator+=;

  auto d = Disc();

  for (std::size_t i=0; i<gid.size(); ++i) {
    auto bid = tk::cref_find( d->Bid(), gid[i] );
    Assert( bid < m_rhsc.size(), "Indexing out of bounds" );
    m_rhsc[ bid ] += R[i];
  }

  // When we have heard from all chares we communicate with, this chare is done
  if (++m_nrhs == d->Msum().size()) {
    m_nrhs = 0;
    comrhs_complete();
  }
}

void
ALECG::solve()
// *****************************************************************************
//  Solve low and high order diagonal systems
// *****************************************************************************
{
  const auto ncomp = m_rhs.nprop();

  auto d = Disc();

  // Combine own and communicated contributions to rhs
  for (const auto& b : d->Bid()) {
    auto lid = tk::cref_find( d->Lid(), b.first );
    const auto& brhsc = m_rhsc[ b.second ];
    for (ncomp_t c=0; c<ncomp; ++c) m_rhs(lid,c,0) += brhsc[c];
  }

  // Zero communication buffers for next time step
  for (auto& b : m_rhsc) std::fill( begin(b), end(b), 0.0 );

  // Solve sytem
  // m_du = m_rhs / m_lhs;

  // Compute diagnostics, e.g., residuals
  auto diag_computed = m_diag.compute( *d, m_u );
  // Increase number of iterations and physical time
  d->next();
  // Signal that diagnostics have been computed (or in this case, skipped)
  if (!diag_computed) diag();
  // Optionally refine mesh
  refine();
}

void
ALECG::writeFields( tk::real time )
// *****************************************************************************
// Output mesh-based fields to file
//! \param[in] time Physical time
// *****************************************************************************
{
  auto d = Disc();

  // Only write if the last time is different than the current one
  if (std::abs(d->LastFieldWriteTime() - time) <
      std::numeric_limits< tk::real >::epsilon() )
    return;

  // Save time stamp at which the last field write happened
  d->LastFieldWriteTime() = time;

  // Increase field output iteration count
  ++m_itf;

  // Lambda to collect node fields output from all PDEs
  auto nodefields = [&]() {
    auto u = m_u;   // make a copy as eq::output() may overwrite its arg
    std::vector< std::vector< tk::real > > output;
    for (const auto& eq : g_cgpde) {
      auto o = eq.fieldOutput( time, m_vol, d->Coord(), d->V(), u );
      output.insert( end(output), begin(o), end(o) );
    }
    return output;
  };

  #ifdef HAS_ROOT
  auto filetype = g_inputdeck.get< tag::selected, tag::filetype >();

  if (filetype == tk::ctr::FieldFileType::ROOT) {

    // Create Root writer
    tk::RootMeshWriter rmw( d->filename(), 1 );
    // Write time stamp
    rmw.writeTimeStamp( m_itf, time );
    // Write node fields to file
    d->writeNodeSolution( rmw, m_itf, nodefields() );

  } else
  #endif
  {

    // if the previous iteration refined the mesh, start by writing the mesh
    if (m_itf == 1) {
      // Output chare mesh to file
      d->writeMesh( m_fd.Bface(), m_fd.Triinpoel(), m_fd.Bnode() );
      // Output fields metadata to output file
      d->writeNodeMeta();
    }

    // Create ExodusII writer
    tk::ExodusIIMeshWriter ew( d->filename(), tk::ExoWriter::OPEN );
    // Write time stamp
    ew.writeTimeStamp( m_itf, time );
    // Write node fields to file
    d->writeNodeSolution( ew, m_itf, nodefields() );

  }
}

void
ALECG::out()
// *****************************************************************************
// Output mesh field data
// *****************************************************************************
{
  auto d = Disc();

  // Output field data to file if not in benchmark mode
  if ( !g_inputdeck.get< tag::cmd, tag::benchmark >() ) {

    if ( !((d->It()) % g_inputdeck.get< tag::interval, tag::field >()) )
      writeFields( d->T() );

    // Output final field data to file (regardless of whether it was requested)
    const auto term = g_inputdeck.get< tag::discr, tag::term >();
    const auto eps = std::numeric_limits< tk::real >::epsilon();
    const auto nstep = g_inputdeck.get< tag::discr, tag::nstep >();
    if ( (std::fabs(d->T()-term) < eps || d->It() >= nstep ) )
      writeFields( d->T() );

  }
}

void
ALECG::advance( tk::real newdt )
// *****************************************************************************
// Advance equations to next time step
//! \param[in] newdt Size of this new time step
// *****************************************************************************
{
  auto d = Disc();

  // Set new time step size
  d->setdt( newdt );

  // Compute rhs for next time step
  rhs();
}

void
ALECG::diag()
// *****************************************************************************
// Signal the runtime system that diagnostics have been computed
// *****************************************************************************
{
  diag_complete();
}

void
ALECG::refine()
// *****************************************************************************
// Optionally refine/derefine mesh
// *****************************************************************************
{
  auto d = Disc();

  auto dtref = g_inputdeck.get< tag::amr, tag::dtref >();
  auto dtfreq = g_inputdeck.get< tag::amr, tag::dtfreq >();

  // if t>0 refinement enabled and we hit the frequency
  if (dtref && !(d->It() % dtfreq)) {   // refine

    d->Ref()->dtref( d->T(), thisProxy, m_fd.Bnode() );

  } else {      // do not refine

    ref_complete();
    lhs_complete();
    resize_complete();

  }
}

void
ALECG::resize( const tk::UnsMesh::Chunk& chunk,
               const tk::UnsMesh::Coords& coord,
               const tk::Fields& u,
               const std::unordered_map< int,
                     std::vector< std::size_t > >& msum,
               const std::map< int, std::vector< std::size_t > >& bnode )
// *****************************************************************************
//  Receive new mesh from Refiner
//! \param[in] chunk New mesh chunk (connectivity and global<->local id maps)
//! \param[in] coord New mesh node coordinates
//! \param[in] u New solution on new mesh
//! \param[in] msum New node communication map
//! \param[in] bnode Map of boundary-node lists mapped to corresponding
//!   side set ids for this mesh chunk
// *****************************************************************************
{
  auto d = Disc();

  // Set flag that indicates that we are during time stepping
  m_initial = false;

  // Zero field output iteration count between two mesh refinement steps
  m_itf = 0;

  // Increase number of iterations with mesh refinement
  ++d->Itr();

  // Resize mesh data structures
  d->resize( chunk, coord, msum );

  // Update (resize) solution on new mesh
  m_u = u;

  // Resize auxiliary solution vectors
  auto npoin = coord[0].size();
  auto nprop = m_u.nprop();
  m_du.resize( npoin, nprop );
  m_lhs.resize( npoin, nprop );
  m_rhs.resize( npoin, nprop );

  // Update physical-boundary node lists
  m_fd.Bnode() = bnode;

  // Resize communication buffers
  resizeComm();

  // Activate SDAG waits for re-computing the left-hand side
  thisProxy[ thisIndex ].wait4lhs();

  ref_complete();

  contribute( CkCallback(CkReductionTarget(Transporter,workresized), d->Tr()) );
}

void
ALECG::eval()
// *****************************************************************************
// Evaluate whether to continue with next step
// *****************************************************************************
{
  auto d = Disc();

  // Output field data to file
  out();
  // Output one-liner status report to screen
  d->status();

  const auto term = g_inputdeck.get< tag::discr, tag::term >();
  const auto nstep = g_inputdeck.get< tag::discr, tag::nstep >();
  const auto eps = std::numeric_limits< tk::real >::epsilon();

  // If neither max iterations nor max time reached, continue, otherwise finish
  if (std::fabs(d->T()-term) > eps && d->It() < nstep) {
    AtSync();   // Migrate here if needed
    dt();
  } else {
    contribute( CkCallback( CkReductionTarget(Transporter,finish), d->Tr() ) );
  }
}

#include "NoWarning/alecg.def.h"
@endcode

@section inciter_newscheme_work 5. Making it work

@subsection inciter_newscheme_chare_Transporter Inciter/Transporter.C

@code{.diff}
$ git diff src/Inciter/Transporter.C
diff --git a/src/Inciter/Transporter.C b/src/Inciter/Transporter.C
index 4c7117a9..5a4d176a 100644
--- a/src/Inciter/Transporter.C
+++ b/src/Inciter/Transporter.C
@@ -524,7 +524,8 @@ Transporter::diagHeader()
   // Collect variables names for integral/diagnostics output
   std::vector< std::string > var;
   const auto scheme = g_inputdeck.get< tag::discr, tag::scheme >();
-  if (scheme == ctr::SchemeType::MatCG || scheme == ctr::SchemeType::DiagCG)
+  if (scheme == ctr::SchemeType::MatCG || scheme == ctr::SchemeType::DiagCG ||
+      scheme == ctr::SchemeType::ALECG)
     for (const auto& eq : g_cgpde) varnames( eq, var );
   else if (scheme == ctr::SchemeType::DG || scheme == ctr::SchemeType::DGP1)
     for (const auto& eq : g_dgpde) varnames( eq, var );
@endcode

@subsection inciter_newscheme_chare_inciter Main/inciter.ci

@code{.diff}
$ git diff src/Main/inciter.ci
diff --git a/src/Main/inciter.ci b/src/Main/inciter.ci
index bf7eac98..e9b114b6 100644
--- a/src/Main/inciter.ci
+++ b/src/Main/inciter.ci
@@ -14,6 +14,7 @@ mainmodule inciter {
   extern module partitioner;
   extern module matcg;
   extern module diagcg;
+  extern module alecg;
   extern module dg;
   extern module charestatecollector;
@endcode

@subsection inciter_newscheme_chare_PDEStack PDE/PDEStack.C

@code{.diff}
$ git diff src/PDE/PDEStack.C
diff --git a/src/PDE/PDEStack.C b/src/PDE/PDEStack.C
index 438cb5e3..9b2e14e7 100644
--- a/src/PDE/PDEStack.C
+++ b/src/PDE/PDEStack.C
@@ -108,7 +108,9 @@ PDEStack::selectedCG() const
   std::vector< CGPDE > pdes;                // will store instantiated PDEs

   const auto sch = g_inputdeck.get< tag::discr, tag::scheme >();
-  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG) {
+  if (sch == ctr::SchemeType::MatCG || sch == ctr::SchemeType::DiagCG ||
+      sch == ctr::SchemeType::ALECG)
+  {

     for (const auto& d : g_inputdeck.get< tag::selected, tag::pde >()) {
       if (d == ctr::PDEType::TRANSPORT)
@endcode

*/
} // inciter::
