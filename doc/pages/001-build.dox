/*!
  @page      build How to build

@tableofcontents{xml}

This page discusses various ways of building Quinoa, including requirements,
optional libraries, defaults, and build system options.

@section build_stages Two-stage build

Quinoa is built in two stages, of which the first one may be optional:

 1. Build third-party libraries (TPLs)
 2. Build Quinoa

Both stages consist of the following two steps

 - Use cmake to configure the build
 - Perform the build

The first step may be optional if all TPLs are found on the system or are
pre-installed and/or configured, e.g., via environment modules.

@note If some libraries are not found by the Quinoa cmake step, not all
executable targets will be configured. Examples are builds configured for only a
single executable, see @ref build_specific_executables, or a build
configured for only building the documentation, see
https://github.com/quinoacomputing/buildenv/blob/master/debian-doc.

@section build_default Quick start

The easiest, but not necessarily the quickest, way to build Quinoa is to use the
defaults. At the minimum cmake, Fortran, C, C++ compilers, and MPI are required.

To install these on a Debian-based Linux do

       sudo apt-get install cmake gfortran gcc g++ openmpi-bin libopenmpi-dev

If you have not yet, clone the code with the external packages (third party
libraries, TPLs):

       git clone --recurse-submodules https://github.com/quinoacomputing/quinoa.git

Next is to build the TPLs in an empty directory:

       cd quinoa
       mkdir external/build
       cd external/build
       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCMAKE_BUILD_TYPE=Release ..
       make -sj$(grep -c processor /proc/cpuinfo)

If the above went fine, we build the code, in a new empty build directory:

       cd quinoa
       mkdir build
       cd build
       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_BUILD_TYPE=Release ../src
       make -sj$(grep -c processor /proc/cpuinfo)

If this also went fine, let's run the unit-, and regression tests in the build
directory:

       cd quinoa/build
       ./charmrun +p$(grep -c processor /proc/cpuinfo) Main/unittest -v -q
       ctest -j$(grep -c processor /proc/cpuinfo) -LE extreme

This will run all tests, except those that would take a long time. If all of the
above steps finished without error, you have successfully built Quinoa. You can
run the executables from `build/Main` or install them with

        cmake install

The default install directory is `/usr/local`, which usually needs root
permissions. You can change that by configuring a different path in the
`CMAKE_INSTALL_PREFIX` cmake variable.

@section build_specific_executables Building specific executables only

The default build process, described in @ref build_default builds all
executables. If you only care about a particular tool, e.g., @ref inciter, you
can tell the build system to build only that by setting the `INCITER_ONLY`
cmake variable to `true`:

       cd quinoa
       mkdir external/build
       cd external/build
       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCMAKE_BUILD_TYPE=Release -DINCITER_ONLY=true ..
       make -sj$(grep -c processor /proc/cpuinfo)

This will build only the TPLs required for inciter. The rest of the build
process is the same as in @ref build_default : running cmake configuring Quinoa
will enable only those build targets for which it finds the required TPLs.
Such `*_ONLY` cmake variables are defined for all executable targets.

@section build_nonrecursive Working with a non-recursive clone

The default build process, described in @ref build_default, instructs you to do
a _recursive_ clone, which clones not only the source code for Quinoa but also
all external packages (third-party libraries, TPLs). The TPLs are pulled in to
directory `external/` as git submodules and contain significantly more data and
files than the Quinoa source. If you plan to do code development, it is quicker
to work with the repository (changing branches, stashing, etc.) if you work
with a _non-recursive_ clone.

To make this work, we need to clone the TPLs separately:

       git clone https://github.com/quinoacomputing/quinoa-tpl.git

Then build the TPLs using a similar process as in @ref build_default :

       cd quinoa-tpl
       mkdir build
       cd build
       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCMAKE_BUILD_TYPE=Release ..
       make -sj$(grep -c processor /proc/cpuinfo)

By default, this will install all TPLs in
`quinoa-tpl/install/<compiler>-<arch>/`, e.g., `quinoa-tpl/install/gnu-x86_64/`.
Now we can clone Quinoa without cloning the TPLs:

       git clone https://github.com/quinoacomputing/quinoa.git

To build the code using the TPLs installed above, we tell that location to
cmake using the cmake variable `TPL_DIR`:

       cd quinoa
       mkdir build
       cd build
       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_BUILD_TYPE=Release -DTPL_DIR=<path-to-quinoa-tpl>/install/gnu-x86_64/ ../src
       make -sj$(grep -c processor /proc/cpuinfo)

Since the Quinoa clone no longer contain initialized submodules, git
operations are faster. This difference can be significant on network-mounted
drives.

If the need arises, e.g., to pull in changes from the TPL submodules into such a
non-recursive clone, the `external/` directory can still be populated under the
quinoa clone by initializing the submodules:

       cd quinoa
       git submodule init
       git submodule update --recursive
       cd external
       git submodule init
       git submodule update --recursive
       cd ..
       git submodule status --recursive

As you can see form the above, there are two layers of git sumbodules. You can
just use the above as a single, chained command:

       cd quinoa
       git submodule init && git submodule update --recursive && cd external && git submodule init && git submodule update --recursive && cd .. && git submodule status --recursive

After this under `quinoa/external/` the TPLs can be updated, e.g., `git pull`,
etc.  When the TPL sources are, again, no longer needed, we de-populate it:

       cd quinoa
       git submodule deinit --all

@note To effect code-reuse between
[quinoa](https://github.com/quinoacomputing/quinoa) and
[quinoa-tpl](https://github.com/quinoacomputing/quinoa-tpl) the `cmake/`
directory is pulled into _quinoa_ as a git subtree, (and as a submodule into
_quinoa-tpl_) whose origin is https://github.com/quinoacomputing/cmake-modules.
Therefore changes to files under `cmake/` should be made to the
[cmake-modules](https://github.com/quinoacomputing/cmake-modules) repository
and then pulled in to _quinoa_ and _quinoa-tpl_. See also the page on on @ref
git_submodules_subtrees.

@section build_systemlibs Using system-wide packages

The default build process, described in @ref build_default, attempts to find
(and if not found, build) all required and optional packages that are enabled
by default. See the section on @ref build_optional for what packages are
enabled by default.  In some platforms, it is advantageous (and could be
faster) to use the packages provided by the system.

On a Debian-based Linux you can pre-install the packages given in

       quinoa/tools/docker/Dockerfile.quinoa-build-debian

On Alpine Linux you can pre-install the packages given in

       quinoa/tools/docker/Dockerfile.quinoa-build-alpine

@section build_mac Building on Mac OS

On Mac OS we do _not_ recommend using the system-wide compilers. Instead, we
use [macports](https://www.macports.org/) to install compilers and OpenMPI:

       port install openmpi-clang60
       port select clang mp-clang-6.0
       port select mpi openmpi-clang60-fortran

You can also use ports to install some TPLs:

       port install pugixml hdf5 +openmpi+clang60+hl

Note that the above is optional, since it may also be installed by the TPL
build, see @ref build_default, but depending on your system you may have better
luck with one or the other.

@section build_clang Build using clang or Intel compilers

The default build process on Linux, described in @ref build_default, uses the
system-wide gnu compiler suite. If you want, you can also use the clang or the
Intel compilers. We do this by either building OpenMPI using clang or Intel or
by using the machine-specific MPI wrappers pointing to the compiler and then
use the build process given in @ref build_default.

@section build_rndq Build using Charm++'s randomized message queues

For serious development work, especially involving asynchronous parallel
programming, we also build Charm++ using randomized message queues. This
enables more thorough testing of the available space for scheduling messages
and thus more heavily testing the asynchronous logic. We do this by configuring
the TPL build as

       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCHARM_EXTRA_ARGS="--enable-error-checking;--with-prio-type=int;--enable-randomized-msgq;--suffix;randq-debug" <path-to-TPL-CMakeLists.txt>

@section build_smp Build using Charm++'s SMP mode

For better performance computing large problems using many threads, Quinoa can
also be used using Charm++'s symmetric multi-processing (SMP) mode. This is can
be done by configuring the TPL build as

       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCHARM_EXTRA_ARGS="smp" <path-to-TPL-CMakeLists.txt>

You can run the unit-, and regression tests in SMP mode as, e.g.,

       ./charmrun +p 34 --bind-to none Main/unittest -v -q +ppn 17
       ctest -j 36 --output-on-failure -LE extreme

The above example will use 36 PEs, distributed into 2 logical (compute) nodes.
See also the Charm++ manual on how to run in SMP mode. Note that SMP mode
configures more regression tests compared to non-SMP mode.

@note Multiple extra arguments to the Charm++ can also be passed to the cmake
variable CMAKE_EXTRA_ARGS separated by semi-colons.

@section build_static Static build

Some machines, e.g., Crays, prefer builds using static libraries. This can be
done by passing the cmake argument `-DBUILD_SHARED_LIBS=off` to _both_ TPL and
Quinoa configure steps. See also @ref build_default.

@section build_projections Building with Charm++'s Projections enabled

To use Charm++'s performance analysis tool, Projections, you can build Charm++
with

       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_Fortran_COMPILER=mpif90 -DCHARM_EXTRA_ARGS="--enable-tracing;--enable-commthread-tracing" <path-to-TPL-CMakeLists.txt>

Then configure the Quinoa build with the extra link arguments:

       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_BUILD_TYPE=Release -DEXTRA_LINK_ARGS="-tracemode projections" <path-to-Quinoa-src-CMakeLists.txt>

See also the Charm++ Projections manual.

@section build_ninja Using ninja instead of make

Similar to other CMake/C++ projects, Quinoa can also be built with ninja instead
of make, by configuring the Quinoa build with

       cmake -DCMAKE_CXX_COMPILER=mpicxx -DCMAKE_C_COMPILER=mpicc -DCMAKE_BUILD_TYPE=Release -GNinja <path-to-Quinoa-src-CMakeLists.txt>

@section build_optional Optional third-party libraries

The default build process, described in @ref build_default, will attempt to
build a set of default TPLs. Not all TPLs are required, some are optional and
some must be specifically enabled if needed. Then Quinoa can be configured to
build whatever it can based on the libraries it can find. See also the section
on @ref build_specific_executables.

All libraries, whether they are required or optional, and whether they are
search for and built by default or expected to be available system-wide, are
listed on page @ref licenses.

@section build_debug Building in Debug mode

Similar to other cmake projects, Quinoa can be configured for `Debug`,
`Release`, or other types of builds cmake supports. As usual, this is done by
setting the `CMAKE_BUILD_TYPE` variable, e.g., `-DCMAKE_BUILD_TYPE=Debug`.

@section build_disable Disabling packages

Sometimes it may be necessary to disable searching for packages, e.g., due to
broken or unsuitable system-wide installs, etc. This can be done by configuring
the TPL build by passing to cmake, e.g.,

       -DCMAKE_DISABLE_FIND_PACKAGE_Boost=true

@section build_cpplibrary Configuring the C++ standard library

We routinely use and test _libc++_ and _libstdc++_.  Which one to use can be
configured by the cmake variable `STDLIBCPP`, as

       -DSTDLIBCPP=libc++

or

       -DSTDLIBCPP=libstdc++

@note The `STDLIBCPP` cmake variable is ignored if the gnu compiler is used,
for which it is always _libstdc++_ is used.

@warning The configuration for the standard library must be specified so that
_both_ the TPL and the Quinoa builds use the same implementation. See the
section on @ref build_stages.

@section build_system_specs Build system features, requirements, and defaults

General requirements for configuring the TPL as well as Quinoa builds:

- In-source builds are not allowed.

- Shared cmake code is in https://github.com/quinoacomputing/cmake-modules.git,
pulled in as a git submodule into the TPL build and a git subtree into the
Quinoa build. See also the page on @ref git_submodules_subtrees.

- The TPL build requires a Fortran, C, and a C++ compiler.

- The Quinoa build requires only a C and a C++ compiler.

- If unspecified, the default install directory, configured by the cmake
  variable `CMAKE_INSTALL_PREFIX`, for the TPL build is
  `<root>/install/<compiler>-<architecture>/`, where `<root>` is the root of the
  TPL repository clone. In a recursive clone `<root>` is `quinoa/external`.

- If unspecified, the default TPL directory, configured by the cmake variable
  `TPL_DIR`, for the Quinoa build is
  `<root>/external/install/<compiler>-architecture>/`, where `<root>` is the
  root of the Quinoa repository clone.

- For the list of TPLs searched (and if not found, built) by default, see
  `<quinoa-tpl>/CMakeListst.txt`, section starting by the comment line

       # Set which libraries are built/searched by default

- Currently, MPI is required and Charm++ is built on top of MPI.

- The default C++ standard library is _libstdc++_ for gnu compilers, and
  _libc++_ for clang and Intel.

@section build_docker Helpful docker image configurations

You can get more examples on ways we build Quinoa by browsing the following
docker images:

- https://github.com/quinoacomputing/quinoa/tree/master/tools/docker
- https://github.com/quinoacomputing/quinoa-tpl/tree/master/docker
- https://github.com/quinoacomputing/buildenv

@section build_cmake Main cmake files

The most important (top-level) files responsible for configuring the build
system described here are:

- [cmake/TPLs.cmake](https://github.com/quinoacomputing/quinoa/blob/develop/cmake/TPLs.cmake)
- [external/CMakeLists.txt](https://github.com/quinoacomputing/quinoa-tpl/blob/master/CMakeLists.txt)
- [src/CMakeLists.txt](https://github.com/quinoacomputing/quinoa/blob/develop/src/CMakeLists.txt)

If you have questions not answered here, consult the above.

@section build_feedback Feedback

If you would like to improve this page, contact us using the links in the
footer below or submit a pull request on [github](https://github.com/quinoacomputing/quinoa).

*/
