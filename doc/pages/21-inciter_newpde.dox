namespace inciter {
/*!
  \page      inciter_newpde How to add a new PDE type to Inciter

@tableofcontents{xml}

This page describes how to add a new PDE type to @ref inciter_main.

@ref inciter_main supports multiple partial differential equation (PDE) types.
At the time of this writing there are two PDE types: `Transport` and `CompFlow`.
The former is specialized to solving transport equations of single or multiple
independent scalars, governed by a set of independent advection-diffusion
equations, while the latter is specialized to solving the Euler and
Navier-Stokes equations for single-material compressible ideal gases.  The
simplest way to learn about the currently implemented PDE types and how their
source is organized into directories and files is to do

```
cd <quinoa>/src/PDE
tree
```

which at this time gives
@code{.ansi}
.
├── CGPDE.h
├── CMakeLists.txt
├── CompFlow
│   ├── CGCompFlow.h
│   ├── DGCompFlow.h
│   ├── Physics
│   │   ├── CGEuler.h
│   │   ├── CG.h
│   │   ├── CGNavierStokes.h
│   │   ├── DGEuler.h
│   │   ├── DG.h
│   │   └── DGMultiMatVelEq.h
│   ├── Problem
│   │   ├── NLEnergyGrowth.h
│   │   ├── RayleighTaylor.h
│   │   ├── SedovBlastwave.h
│   │   ├── SodShocktube.h
│   │   ├── TaylorGreen.h
│   │   ├── UserDefined.h
│   │   └── VorticalFlow.h
│   └── Problem.h
├── ConfigureCompFlow.C
├── ConfigureCompFlow.h
├── ConfigureMultiMatCompFlow.C
├── ConfigureMultiMatCompFlow.h
├── ConfigureTransport.C
├── ConfigureTransport.h
├── DGPDE.h
├── FunctionPrototypes.h
├── Integrate
│   ├── Boundary.C
│   ├── Boundary.h
│   ├── Initialize.C
│   ├── Initialize.h
│   ├── Mass.C
│   ├── Mass.h
│   ├── Quadrature.C
│   ├── Quadrature.h
│   ├── Riemann
│   │   ├── HLLC.h
│   │   ├── LaxFriedrichs.h
│   │   ├── RiemannFactory.C
│   │   ├── RiemannFactory.h
│   │   ├── RiemannSolver.h
│   │   └── Upwind.h
│   ├── Source.C
│   ├── Source.h
│   ├── Surface.C
│   ├── Surface.h
│   ├── Volume.C
│   └── Volume.h
├── Limiter.C
├── Limiter.h
├── MultiMatCompFlow
│   ├── DGMultiMatCompFlow.h
│   ├── Physics
│   │   ├── DG.h
│   │   └── DGVelEq.h
│   ├── Problem
│   │   ├── UserDefined.h
│   │   └── VorticalFlow.h
│   └── Problem.h
├── PDEFactory.h
├── PDEStack.C
├── PDEStack.h
└── Transport
    ├── CGTransport.h
    ├── DGTransport.h
    ├── Physics
    │   ├── CGAdvDiff.h
    │   ├── CGAdvection.h
    │   ├── CG.h
    │   ├── DGAdvection.h
    │   └── DG.h
    ├── Problem
    │   ├── CylAdvect.h
    │   ├── GaussHump.h
    │   ├── ShearDiff.h
    │   └── SlotCyl.h
    └── Problem.h

11 directories, 69 files
@endcode

Once can see separate directories for `CompFlow` and `Transport`, each with
subdirectories `Physics` and `Problem`. For example, two PDE classes are
implemented under `CompFlow`: `CGCompFlow` and `DGCompFlow`, using continuous
and discoontinuous Galerkin finite element (`CG`, `DG`) discretizations,
respectively,

This page describes how to add a new PDE, such as Transport` or `CompFlow`.

@section inciter_newpde_rationale Rationale and plan

This page will discuss how to add a new PDE type by adding one for
multi-material compressible flow using a `DG` finite element discretization. We
will explain how and where to create the new files for the PDE class, its
`Physics` and `Problem` policy classes, and how to define these so the existing
discontinuous Galerkin integration driver class, DG, can drive it (potentially
coupled to other existing and future `DG` systems) and so the PDE type can be
instantiated from a factory based on user input, similar to the existing PDE
types. What will _not_ be described are the details of the implementation of
the discretization of the newly added equation system and its algoritm. We only
describe how to fit those details into the existing design and thus reuse and
build on the software infrastructure that support such a new algorithm, e.g.,
user input, mesh I/O, partitioning using over-decomposition, automatic load
balancing via migration, etc.

@section inciter_newpde_input 1. Specification of a PDE in the input file

A PDE type, or more precisely, a PDE _system_ is selected by the user via
specifying a PDE-block in the @ref inciter_main inut file. An example,
configuring the existing `CompFlow` PDE is given by a `compflow...end` block,

@code{.sh}
inciter
  ...
  scheme dg
  ...
  compflow
    depvar u    # assign dependent variable 'u' to this PDE
    physics euler       # select 'euler' as compressible flow physics policy
    problem vortical_flow       # select 'vortical flow` as problem policy
    ...
  end
  ...
end
@endcode

This is a snippet, configuring inciter to compute a single PDE system giverning
compressible flow. Every PDE type is configured via a physics and a problem
policy. Here The physics is `euler`, configuring the solution of the Euler
equations for inviscid flow, and problem is `vortical_flow`, which is a test
case derived using the method of manufactured solutions, specifying a prescribed
velocity field with vortices. Since the analytical solution is known for this
specific case, it can be used to verify the correctness of the implementation of
the algorithm and the the order of accuracy of the numerical method.

The important parts of this specification are that

1. A new block configures a particular PDE system, such as `compflow...end`.
There can be multiple such PDE-blocks specified, which then will be integrated
together in an unsplit strongly-coupled fashion, e.g, `comppflow` + `transport`
with, say, 12 scalar components, which then together will compreise of a system
of 17 coupled scalar equations.

2. The PDE must be specialized with a selected `physics` type. In the example
above this is `euler`, but this is only the simplest choice. Every PDE has a
default physics which is selected if no physics is specified.

3. The PDE must be specialized with a selected `problem` type. In the example
above this is `vortical_flow`, but this is only one choice. Every PDE has a
default problem which is selected if no problem is specified.

4. The `depvar` keyword specifies the dependent variable by a single character
that is used within the input file to refer to a particular PDE system. Note
that there can be multiple PDE blocks specified with the same or different
types, but their depvar must be unique. This `depvar` then may be used
downstream of its specification to configure a scalar component of a given PDE
to be used as a _refinement variable_ as error indicator for adaptive
refinement. Another way depvars are used is to specify coupling among PDEs. An
example in @ref walker_main, where systems of _stochastic_ differential
equations (SDE) are specified analogously as PDEs in @ref inciter_main, is
given in
[glm_homogeneous_shear.q](https://github.com/quinoacomputing/quinoa/blob/master/regression/walker/Velocity/glm_homogeneous_shear.q),
which couples three systems of SDEs to integrate a joint Fokker-Planck equation
of particle positions, velocities, and turbulent kinetic energy dissipation
rate in a homogeneous shear-driven turbulent flow.

@section inciter_newpde_keyword 2. Add new keywords

To add a new PDE type, we start by adding a new keyword that will be used to
designate it in the input file. Since the new PDE is for methods specifialized
for multi-material compressible flow, we add a new keyword `multimat_compflow`.
We also add a new keyword for a new `physics` policy, `veleq`, to designate an
important feature of the new method to be implemented, velocity equilibrium,
assuming a single velocity field for all materials. Another new keyword we add
is `nmat` which will be used to specify the number of materials for a
multi-material flow. New keyword definitions with their documentation go to
src/Control/Keywords.h`.

@subsection inciter_newpde_keyword_Keywords Control/Keywords.h

@code{.diff}
git diff src/Control/Keywords.h
diff --git a/src/Control/Keywords.h b/src/Control/Keywords.h
index b3fbcebd..c57c65ce 100644
--- a/src/Control/Keywords.h
+++ b/src/Control/Keywords.h
@@ -1727,6 +1727,23 @@ struct ncomp_info {
 };
 using ncomp = keyword< ncomp_info,  TAOCPP_PEGTL_STRING("ncomp") >;
 
+struct nmat_info {
+  static std::string name() { return "nmat"; }
+  static std::string shortDescription() { return
+    "Set number of materials for a system of differential equations"; }
+  static std::string longDescription() { return
+    R"(This keyword is used to specify the number of materials, e.g., for
+    multi-material flow, see also the keyword 'multimat_compflow' and
+    'veleq'.)";
+  }
+  struct expect {
+    using type = std::size_t;
+    static constexpr type lower = 1;
+    static std::string description() { return "uint"; }
+  };
+};
+using nmat = keyword< nmat_info,  TAOCPP_PEGTL_STRING("nmat") >;
+
 struct ttyi_info {
   static std::string name() { return "ttyi"; }
   static std::string shortDescription() { return
@@ -3769,6 +3786,23 @@ struct compflow_euler_info {
 };
 using compflow_euler = keyword< compflow_euler_info, TAOCPP_PEGTL_STRING("euler") >;
 
+struct multimat_compflow_veleq_info {
+  using code = Code< V >;
+  static std::string name() { return "Velocity equilibrium"; }
+  static std::string shortDescription() { return "Specify the multi-material "
+    " compressible flow with velocity equilibrium as physics configuration"; }
+  static std::string longDescription() { return
+    R"(This keyword is used to select a compressible flow algorithm as physics
+    configuration designed for multiple materials assuming velocity equailibrium
+    (single velocity). Example: "multimat_compflow physics veleq end")";
+    }
+  struct expect {
+    static std::string description() { return "string"; }
+  };
+};
+using multimat_compflow_veleq =
+  keyword< multimat_compflow_veleq_info, TAOCPP_PEGTL_STRING("veleq") >;
+
 struct advection_info {
   using code = Code< A >;
   static std::string name() { return "Advection"; }
@@ -4368,6 +4402,41 @@ struct compflow_info {
 };
 using compflow = keyword< compflow_info, TAOCPP_PEGTL_STRING("compflow") >;
 
+struct multimat_compflow_info {
+  static std::string name() { return "Compressible multi-material flow"; }
+  static std::string shortDescription() { return "Start configuration block "
+    "for the multi-material compressible flow equations"; }
+  static std::string longDescription() { return
+    R"(This keyword is used to introduce the multimat_compflow ... end block,
+    used to specify the configuration for a system of partial differential
+    equations, governing multi-material compressible fluid flow. Keywords
+    allowed in a multimat_compflow ... end block: )" + std::string("\'")
+    + depvar::string()+ "\', \'"
+    + physics::string() + "\', \'"
+    + problem::string() + "\', \'"
+    + material::string() + "\', \'"
+    + nmat::string() + "\', \'"
+    + pde_alpha::string() + "\', \'"
+    + pde_p0::string() + "\', \'"
+    + pde_betax::string() + "\', \'"
+    + pde_betay::string() + "\', \'"
+    + pde_betaz::string() + "\', \'"
+    + pde_beta::string() + "\', \'"
+    + pde_r0::string() + "\', \'"
+    + pde_ce::string() + "\', \'"
+    + pde_kappa::string() + "\', \'"
+    + bc_dirichlet::string() + "\', \'"
+    + bc_sym::string() + "\', \'"
+    + bc_inlet::string() + "\', \'"
+    + bc_outlet::string() + "\', \'"
+    + bc_extrapolate::string() + "\'. "
+    + R"(For an example multimat_compflow ... end block, see
+      doc/html/inicter_example_multimat_compflow.html.)";
+  }
+};
+using multimat_compflow =
+  keyword< multimat_compflow_info, TAOCPP_PEGTL_STRING("multimat_compflow") >;
+
 struct rcb_info {
   static std::string name() { return "recursive coordinate bisection"; }
   static std::string shortDescription() { return
@endcode

For more details on the various (mandatory and optional) fields of a keyword
specification struct see the documentation in src/Control/Keywords.h.

We also add the new keywords to inciter's grammar's keywords pool:

@subsection inciter_newpde_keyword_InputDeck Control/Inciter/InputDeck/InputDeck.h

@code{.diff}
git diff src/Control/Inciter/InputDeck/InputDeck.h 
diff --git a/src/Control/Inciter/InputDeck/InputDeck.h b/src/Control/Inciter/InputDeck/InputDeck.h
index 39eff786..155c47dc 100644
--- a/src/Control/Inciter/InputDeck/InputDeck.h
+++ b/src/Control/Inciter/InputDeck/InputDeck.h
@@ -70,12 +70,14 @@ class InputDeck :
                                    kw::phg,
                                    kw::inciter,
                                    kw::ncomp,
+                                   kw::nmat,
                                    kw::pde_diffusivity,
                                    kw::pde_lambda,
                                    kw::pde_u0,
                                    kw::bc_dirichlet,
                                    kw::sideset,
                                    kw::compflow,
+                                   kw::multimat_compflow,
                                    kw::ic,
                                    kw::txt_float_format,
                                    kw::txt_float_default,
@@ -95,6 +97,7 @@ class InputDeck :
                                    kw::advdiff,
                                    kw::compflow_navierstokes,
                                    kw::compflow_euler,
+                                   kw::multimat_compflow_veleq,
                                    kw::user_defined,
                                    kw::vortical_flow,
                                    kw::pde_alpha,
@endcode

This is required so that the compiler can generate a database containing the
help for all the keywords in the grammar understood by inciter's control file
parser. The above changes not only add the keyword but also some documentation
that gets displayed when passing the `-C` or `-H` command line arguments to the
inciter executable, so quick help is available at the user's fingertips:

@code{.ansi}
$ inciter -C
inciter Control File Keywords:
...
   multimat_compflow            Start configuration block for the multi-material compressible flow equations
        navierstokes     string Specify the Navier-Stokes (viscous) compressible flow physics configuration
               ncomp       uint Set number of scalar components for a system of differential equations
    nl_energy_growth     string Select the nonlinear energy growth test problem 
                nmat       uint Set number of materials for a system of differential equations
...
$ inciter -H multimat_compflow
inciter control file keyword 'multimat_compflow'

   Start configuration block for the multi-material compressible flow equations

   This keyword is used to introduce the multimat_compflow ... end block, used
   to specify the configuration for a system of partial differential equations,
   governing multi-material compressible fluid flow. Keywords allowed in a
   multimat_compflow ... end block: 'depvar', 'physics', 'problem', 'material',
   'nmat', 'alpha', 'p0', 'betax', 'betay', 'betaz', 'beta', 'r0', 'ce', 'kappa',
   'bc_dirichlet', 'bc_sym', 'bc_inlet', 'bc_outlet', 'bc_extrapolate'. For an
   example multimat_compflow ... end block, see
   doc/html/inicter_example_multimat_compflow.html.
@endcode

@section inciter_newpde_option 3. Add new option switches

Next is to add a new state to the existing PDE option switch, ctr::PDE. This
"option switch" is really only a fancy enum, used to store, in a type-safe
manner, the user's choice of the PDE type after parsing a PDE-block, e.g.,
`compflow ... end` in the control file.  This fancy enum is an option switch
because it inherits from tk::Toggle, defined in Control/Toggle.h, which is a
generic switch (or option), that helps associating enum values to keywords and
querying one based on the other. Extending the existing PDE option switch is
done by extending the list of PDE types in `src/Control/Inciter/Options/PDE.h`:

@subsection inciter_newpde_keyword_PDEOptions Control/Inciter/Options/PDE.h

@code{.diff}
git diff src/Control/Inciter/Options/PDE.h
diff --git a/src/Control/Inciter/Options/PDE.h b/src/Control/Inciter/Options/PDE.h
index 2b4af067..84b6d3ff 100644
--- a/src/Control/Inciter/Options/PDE.h
+++ b/src/Control/Inciter/Options/PDE.h
@@ -22,7 +22,8 @@ namespace ctr {
 
 //! Differential equation types
 enum class PDEType : uint8_t { TRANSPORT=0,
-                               COMPFLOW };
+                               COMPFLOW,
+                               MULTIMAT_COMPFLOW };
 
 //! Pack/Unpack: forward overload to generic enum class packer
 inline void operator|( PUP::er& p, PDEType& e ) { PUP::pup( p, e ); }
@@ -40,6 +41,7 @@ class PDE : public tk::Toggle< PDEType > {
     // List valid expected choices to make them also available at compile-time
     using keywords = brigand::list< kw::transport
                                   , kw::compflow
+                                  , kw::multimat_compflow
                                   >;
 
     //! Constructor: pass associations references to base, which will handle
@@ -48,10 +50,12 @@ class PDE : public tk::Toggle< PDEType > {
       tk::Toggle< PDEType >( "Partial differential equation",
         //! Enums -> names
         { { PDEType::TRANSPORT, kw::transport::name() },
-          { PDEType::COMPFLOW, kw::compflow::name() } },
+          { PDEType::COMPFLOW, kw::compflow::name() },
+          { PDEType::MULTIMAT_COMPFLOW, kw::multimat_compflow::name() } },
         //! keywords -> Enums
         { { kw::transport::string(), PDEType::TRANSPORT },
-          { kw::compflow::string(), PDEType::COMPFLOW } } ) {}
+          { kw::compflow::string(), PDEType::COMPFLOW },
+          { kw::multimat_compflow::string(), PDEType::MULTIMAT_COMPFLOW } } ) {}
 };
 
 } // ctr::
@endcode

We also augment the switch used for selecting the physics policy:

@subsection inciter_newpde_keyword_PhysicsOptions Control/Inciter/Options/Physics.h

@code{.diff}
git diff src/Control/Inciter/Options/Physics.h
diff --git a/src/Control/Inciter/Options/Physics.h b/src/Control/Inciter/Options/Physics.h
index d24ccf1d..f59e85c1 100644
--- a/src/Control/Inciter/Options/Physics.h
+++ b/src/Control/Inciter/Options/Physics.h
@@ -23,7 +23,8 @@ namespace ctr {
 enum class PhysicsType : uint8_t { ADVECTION=0,
                                    ADVDIFF,
                                    EULER,
-                                   NAVIERSTOKES };
+                                   NAVIERSTOKES,
+                                   MULTIMAT_VELEQ };
 
 //! Pack/Unpack PhysicsType: forward overload to generic enum class packer
 inline void operator|( PUP::er& p, PhysicsType& e ) { PUP::pup( p, e ); }
@@ -35,8 +36,9 @@ class Physics : public tk::Toggle< PhysicsType > {
     //! Valid expected choices to make them also available at compile-time
     using keywords = brigand::list< kw::advection
                                   , kw::advdiff
-                                  , kw::compflow_navierstokes
                                   , kw::compflow_euler
+                                  , kw::compflow_navierstokes
+                                  , kw::multimat_compflow_veleq
                                   >;
 
     //! \brief Options constructor
@@ -50,12 +52,16 @@ class Physics : public tk::Toggle< PhysicsType > {
         { { PhysicsType::ADVECTION, kw::advection::name() },
           { PhysicsType::ADVDIFF, kw::advdiff::name() },
           { PhysicsType::EULER, kw::compflow_euler::name() },
-          { PhysicsType::NAVIERSTOKES, kw::compflow_navierstokes::name() } },
+          { PhysicsType::NAVIERSTOKES, kw::compflow_navierstokes::name() },
+          { PhysicsType::MULTIMAT_VELEQ, kw::multimat_compflow_veleq::name() }
+        },
         //! keywords -> Enums
         { { kw::advection::string(), PhysicsType::ADVECTION },
           { kw::advdiff::string(), PhysicsType::ADVDIFF },
           { kw::compflow_euler::string(), PhysicsType::EULER },
-          { kw::compflow_navierstokes::string(), PhysicsType::NAVIERSTOKES } } )
+          { kw::compflow_navierstokes::string(), PhysicsType::NAVIERSTOKES },
+          { kw::multimat_compflow_veleq::string(),
+            PhysicsType::MULTIMAT_VELEQ } } )
     {
        brigand::for_each< keywords >( assertPolicyCodes() );
     }
@@ -89,6 +95,7 @@ class Physics : public tk::Toggle< PhysicsType > {
       , { PhysicsType::ADVDIFF, *kw::advdiff::code() }
       , { PhysicsType::EULER, *kw::compflow_euler::code() }
       , { PhysicsType::NAVIERSTOKES, *kw::compflow_navierstokes::code() }
+      , { PhysicsType::MULTIMAT_VELEQ, *kw::multimat_compflow_veleq::code() }
     };
 };
@endcode

@section inciter_newpde_grammar 4. Add parsing/grammar for the new keywords

After adding the new keywords `multimat_compflow`, `nmat`, and `veleq`, we
have to teach the input file parser to recognize them.

First we augment the data structures that store data parsed associted with the
new keywords. First is the number of scalar components for each PDE type:

@subsection inciter_newpde_grammar_components Control/Inciter/Components.h

@code{.diff}
git diff src/Control/Inciter/Components.h
diff --git a/src/Control/Inciter/Components.h b/src/Control/Inciter/Components.h
index 64f0696f..ef51a9e9 100644
--- a/src/Control/Inciter/Components.h
+++ b/src/Control/Inciter/Components.h
@@ -17,8 +17,9 @@ namespace ctr {
 
 //! Number of components of partial differential equations
 using ncomps = tk::ctr::ncomponents<
-  tag::transport,    std::vector< tk::ctr::ncomp_type >,
-  tag::compflow,     std::vector< tk::ctr::ncomp_type >
+  tag::transport,             std::vector< tk::ctr::ncomp_type >,
+  tag::compflow,              std::vector< tk::ctr::ncomp_type >,
+  tag::multimat_compflow,     std::vector< tk::ctr::ncomp_type >
 >;
 
 } // ctr::
@endcode

tk::ctr::ncomponents is a tuple of vectors that stores the number of scalar
components for each PDE type parsed. It is a vector for each PDE type because
there can be multiple PDE systems of each type.

We also create a new tuple to store data during parsing the
`multimat_compflow...end` block:

@subsection inciter_newpde_grammar_types Control/Inciter/Types.h

@code{.diff}
git diff src/Control/Inciter/Types.h
index 4bc3bf64..65a3235f 100644
--- a/src/Control/Inciter/Types.h
+++ b/src/Control/Inciter/Types.h
@@ -184,10 +184,46 @@ using CompFlowPDEParameters = tk::tuple::tagged_tuple<
   tag::npar,          std::vector< kw::npar::info::expect::type >
 >;
 
+//! Compressible flow equation parameters storage
+using MultiMatCompFlowPDEParameters = tk::tuple::tagged_tuple<
+  tag::depvar,        std::vector< char >,
+  tag::physics,       std::vector< PhysicsType >,
+  tag::problem,       std::vector< ProblemType >,
+  tag::bcdir,         std::vector< std::vector<
+                       kw::sideset::info::expect::type > >,
+  tag::bcsym,         std::vector< std::vector<
+                       kw::sideset::info::expect::type > >,
+  tag::bcinlet,       std::vector< std::vector<
+                        kw::sideset::info::expect::type > >,
+  tag::bcoutlet,      std::vector< std::vector<
+                        kw::sideset::info::expect::type > >,
+  tag::bcextrapolate, std::vector< std::vector<
+                         kw::sideset::info::expect::type > >,
+  //! Parameter vector (for specific, e.g., verification problems)
+  tag::alpha,         std::vector< kw::pde_alpha::info::expect::type >,
+  //! Parameter vector (for specific, e.g., verification problems)
+  tag::beta,          std::vector< kw::pde_beta::info::expect::type >,
+  //! Parameter vector (for specific, e.g., verification problems)
+  tag::p0,            std::vector< kw::pde_p0::info::expect::type >,
+  //! Material ID
+  tag::id,            std::vector< kw::id::info::expect::type >,
+  //! Ratio of spec heats
+  tag::gamma,         std::vector< kw::mat_gamma::info::expect::type >,
+  //! Dynamic viscosity
+  tag::mu,            std::vector< kw::mat_mu::info::expect::type >,
+  //! Spec. heat at const vol.
+  tag::cv,            std::vector< kw::mat_cv::info::expect::type >,
+  //! Heat conductivity
+  tag::k,             std::vector< kw::mat_k::info::expect::type >,
+  //! number of materials
+  tag::nmat,          std::vector< kw::nmat::info::expect::type >
+>;
+
 //! Parameters storage
 using parameters = tk::tuple::tagged_tuple<
-  tag::transport,   TransportPDEParameters,
-  tag::compflow,    CompFlowPDEParameters
+  tag::transport,            TransportPDEParameters,
+  tag::compflow,             CompFlowPDEParameters,
+  tag::multimat_compflow,    MultiMatCompFlowPDEParameters
 >;
 
 //! PEGTL location/position type to use throughout all of Inciter's parsers
@endcode

Note that in ctr::MultiMatCompFlowPDEParameters every field is a vector, since
multiple systems of this PDE type can be configured. Also note that this is
where the dependent variable, physics policy (ctr::PhysicsType enum), the
problem policy (ctr::ProblemType enum), boundary conditions,
problem-configuration-specific parameters, and the number of materials are all
store here. This is data that is either parsed from the user or can be computed
immediately after and based on user input.

After adding a coupled of new tags, `tag::nmat` and `tag::multimat_compflow`,
behind which the parser stores the tuple ctr::MultiMatCompFlowPDEParameters,
and the number of materials, respectively,

@subsection inciter_newpde_grammar_tags Control/Tags.h

@code{.diff}
git diff src/Control/Tags.h
diff --git a/src/Control/Tags.h b/src/Control/Tags.h
index 188a86d0..9c0b7ec6 100644
--- a/src/Control/Tags.h
+++ b/src/Control/Tags.h
@@ -102,6 +102,7 @@ struct matched {};
 struct part {};
 struct centroid {};
 struct ncomp {};
+struct nmat {};
 struct tty {};
 struct dump {};
 struct plot {};
@@ -176,6 +177,7 @@ struct gid {};
 struct transport {};
 struct advection {};
 struct compflow {};
+struct multimat_compflow {};
 struct problem {};
 struct physics {};
 struct diffusivity {};
@endcode

We are now ready to augment the grammar itself:

@subsection inciter_newpde_grammar_grammar Control/Inciter/InputDeck/Grammar.h

@code{.diff}
git diff src/Control/Inciter/InputDeck/Grammar.h
diff --git a/src/Control/Inciter/InputDeck/Grammar.h b/src/Control/Inciter/InputDeck/Grammar.h
index 6b16b623..43a9bba7 100644
--- a/src/Control/Inciter/InputDeck/Grammar.h
+++ b/src/Control/Inciter/InputDeck/Grammar.h
@@ -35,8 +35,9 @@ namespace deck {
 
   //! \brief Number of registered equations
   //! \details Counts the number of parsed equation blocks during parsing.
-  static tk::tuple::tagged_tuple< tag::transport, std::size_t,
-                                  tag::compflow,  std::size_t > neq;
+  static tk::tuple::tagged_tuple< tag::transport,          std::size_t,
+                                  tag::compflow,           std::size_t,
+                                  tag::multimat_compflow,  std::size_t > neq;
 
 } // ::deck
 } // ::inciter
@@ -201,6 +202,70 @@ namespace grm {
     }
   };
@endcode

The above tagged tuple, deck::neq, stores the number of equations _during_
parsing the inciter's input file. Since this is part of inciter's parser's
state, it is static and thus only visible locally -- only used by the grammar
and not the rest of the code. deck::neq is used to count the number of PDE
systems parsed.

The code follows is run immediately after the `multimat_compflow...end` block
is finished parsing, thus it is designed to do error checking and set/verify
defaults for this particular PDE system.
 
@code{.diff}
+  //! Rule used to trigger action
+  template< class eq > struct check_multimat_compflow : pegtl::success {};
+  //! \brief Set defaults and do error checking on the multimaterial
+  //!    compressible flow equation block
+  //! \details This is error checking that only the multimaterial compressible
+  //!   flow equation block must satisfy. Besides error checking we also set
+  //!   defaults here as this block is called when parsing of a
+  //!   multimat_compflow...end block has just finished.
+  template< class eq >
+  struct action< check_multimat_compflow< eq > > {
+    template< typename Input, typename Stack >
+    static void apply( const Input& in, Stack& stack ) {
+      using inciter::deck::neq;
+
+      // Error out if no dependent variable has been selected
+      auto& depvar = stack.template get< tag::param, eq, tag::depvar >();
+      if (depvar.empty() || depvar.size() != neq.get< eq >())
+        Message< Stack, ERROR, MsgKey::NODEPVAR >( stack, in );
+
@endcode

First we ensure that a dependent variable has been associated. This is
mandatory, as this identifies the PDE system during parsing. If `depvar` is not
specified in this equation block or the vector that stores the dependent
variables for this equation block does not have the same number of entries as
many PDEs have been configured so far, the variable has not been specified, so
the parser will issue an error when all parsing has been finished.

@code{.diff}
+      // If physics type is not given, default to 'veleq'
+      auto& physics = stack.template get< tag::param, eq, tag::physics >();
+      if (physics.empty() || physics.size() != neq.get< eq >())
+        physics.push_back( inciter::ctr::PhysicsType::MULTIMAT_VELEQ );
+
@endcode

We also ensure that a mandatory physics policy has been selected. If the user
did not select one, the default is the new `veleq` we are adding.

@code{.diff}
+      // Set number of scalar components based on number of materials
+      auto& nmat = stack.template get< tag::param, eq, tag::nmat >();
+      auto& ncomp = stack.template get< tag::component, eq >();
+      if (physics.back() == inciter::ctr::PhysicsType::MULTIMAT_VELEQ) {
+        // physics = multimat_veleq: m-material compressible flow
+        // scalar components: volfrac:m-1 + mass:m + momentum:3 + energy:m
+        // if nmat is unspecified, configure it be 2
+        if (nmat.empty() || nmat.size() != neq.get< eq >()) {
+          Message< Stack, WARNING, MsgKey::NONMAT >( stack, in );
+          nmat.push_back( 2 );
+        }
+        // set ncomp based on nmat
+        auto m = nmat.back();
+        ncomp.push_back( m-1 + m + 3 + m );
+      }
+
@endcode

The number of materials is processed above. If the physics selected is the
newly added velocity equilibrium _and_ the the user did not specify the number
of paterials, first we issue a warning, then we set the number of materials
equal 2. If the user has configured the number materials, we use it, and
compute the number of scalar components, `ncomp`, for this PDE system, as
appropriate for the algorithm.

@code{.diff}
+      // If problem type is not given, default to 'user_defined'
+      auto& problem = stack.template get< tag::param, eq, tag::problem >();
+      if (problem.empty() || problem.size() != neq.get< eq >())
+        problem.push_back( inciter::ctr::ProblemType::USER_DEFINED );
+      else if (problem.back() == inciter::ctr::ProblemType::VORTICAL_FLOW) {
+        const auto& alpha = stack.template get< tag::param, eq, tag::alpha >();
+        const auto& beta = stack.template get< tag::param, eq, tag::beta >();
+        const auto& p0 = stack.template get< tag::param, eq, tag::p0 >();
+        if ( alpha.size() != problem.size() ||
+             beta.size() != problem.size() ||
+             p0.size() != problem.size() )
+          Message< Stack, ERROR, MsgKey::VORTICAL_UNFINISHED >( stack, in );
+      }
+
@endcode

The above is some basic sanity checking on the problem policy selected.

@code{.diff}
+      // Error check Dirichlet boundary condition block for all
+      // multimat_compflow configurations
+      for (const auto& s : stack.template get< tag::param, eq, tag::bcdir >())
+        if (s.empty())
+          Message< Stack, ERROR, MsgKey::BC_EMPTY >( stack, in );
@endcode

Followed by some error checking for Dirichlet boundary conditions. Obviously,
this section can and will grow in the future as more defaults and error
checking will be added.

@code{.diff}
+    }
+  };
+
   //! Rule used to trigger action
   template< class Option, typename...tags >
   struct store_inciter_option : pegtl::success {};
@@ -565,6 +630,55 @@ namespace deck {
                                tag::bcextrapolate > >,
            check_errors< tag::compflow, tk::grm::check_compflow > > {};
 
+  //! compressible multi-material flow
+  struct multimat_compflow :
+         pegtl::if_must<
+           scan_eq< use< kw::multimat_compflow >, tag::multimat_compflow >,
+           tk::grm::block< use< kw::end >,
+                           tk::grm::policy< use,
+                                            use< kw::physics >,
+                                            ctr::Physics,
+                                            tag::multimat_compflow,
+                                            tag::physics >,
+                           tk::grm::policy< use,
+                                            use< kw::problem >,
+                                            ctr::Problem,
+                                            tag::multimat_compflow,
+                                            tag::problem >,
+                           tk::grm::depvar< use,
+                                            tag::multimat_compflow,
+                                            tag::depvar >,
+                           parameter< tag::multimat_compflow,
+                                      kw::nmat,
+                                      tag::nmat >,
+                           material_properties< tag::multimat_compflow >,
+                           parameter< tag::multimat_compflow,
+                                      kw::pde_alpha,
+                                      tag::alpha >,
+                           parameter< tag::multimat_compflow,
+                                      kw::pde_p0,
+                                      tag::p0 >,
+                           parameter< tag::multimat_compflow,
+                                      kw::pde_beta,
+                                      tag::beta >,
+                           bc< kw::bc_dirichlet,
+                               tag::multimat_compflow,
+                               tag::bcdir >,
+                           bc< kw::bc_sym,
+                               tag::multimat_compflow,
+                               tag::bcsym >,
+                           bc< kw::bc_inlet,
+                               tag::multimat_compflow,
+                               tag::bcinlet >,
+                           bc< kw::bc_outlet,
+                               tag::multimat_compflow,
+                               tag::bcoutlet >,
+                           bc< kw::bc_extrapolate,
+                               tag::multimat_compflow,
+                               tag::bcextrapolate > >,
+           check_errors< tag::multimat_compflow,
+                         tk::grm::check_multimat_compflow > > {};
+
@endcode

The above is the code block that augments inciter's input file grammar with the
`multimat_compflow` block. The rules of PEGTL (our parser library) is out of
scope here, but even without knowing the details of _how_ the parsing is done,
one can surely infer _what_ is (and what is _not_) parsed in this block.
Examples of what are parsed: physics and problem policies, depvar, etc., and
what is _NOT_ parsed: number of (scalar) components, c.f., the definition of
the transport equation grammar block, deck::transport, not listed, in
Control/Inciter/InputDeck/Grammar.h.

@code{.diff}
   //! partitioning ... end block
   struct partitioning :
          pegtl::if_must<
@@ -580,7 +694,7 @@ namespace deck {
 
   //! equation types
   struct equations :
-         pegtl::sor< transport, compflow > {};
+         pegtl::sor< transport, compflow, multimat_compflow > {};
 
   //! refinement variable(s) (refvar) ... end block
   struct refvars :
@endcode

We finally include (above) the new `multimat_compflow` grammar block among the
equations recognized by the parser.

One last item is to augment the grammar messages data store to include our new
warning on unspecified number of materials:

@subsection inciter_newpde_grammar_common Control/CommonGrammar.h

@code{.diff}
git diff src/Control/CommonGrammar.h
diff --git a/src/Control/CommonGrammar.h b/src/Control/CommonGrammar.h
index 40c0b71d..c2de296e 100644
--- a/src/Control/CommonGrammar.h
+++ b/src/Control/CommonGrammar.h
@@ -98,6 +98,7 @@ namespace grm {
     WRONGGAUSSIAN,      //!< Wrong number of parameters configuring a PDF
     NEGATIVEPARAM,      //!< Negative variance given configuring a Gaussian
     NONCOMP,            //!< No number of components selected
+    NONMAT,             //!< No number of materials selected
     NORNG,              //!< No RNG selected
     NODT,               //!< No time-step-size policy selected
     MULDT,              //!< Multiple time-step-size policies selected
@@ -187,7 +188,10 @@ namespace grm {
       "variable to solve for." },
     { MsgKey::NONCOMP, "The number of components has not been specified in the "
       "block preceding this position. This is mandatory for the preceding "
-      "block. Use the keyword 'ncomp' to specify the number of components." },
+      "block. Use the keyword 'nmat' to specify the number of components." },
+    { MsgKey::NONMAT, "The number of materials has not been specified in the "
+      "block preceding this position. This is mandatory for the preceding "
+      "block. Use the keyword 'nmat' to specify the number of materials." },
     { MsgKey::NORNG, "The random number generator has not been specified in "
       "the block preceding this position. This is mandatory for the preceding "
       "block. Use the keyword 'rng' to specify the random number generator." },
@endcode

With the above changes, inciter's parser can now recognize the following:

@code{.sh}
inciter
  ...
  scheme dg
  ...
  multimat_compflow
    depvar u    # assign dependent variable 'u' to this PDE
    physics veleq       # select 'euler' as compressible flow physics policy
    problem vortical_flow       # select 'vortical flow` as problem policy
    nmat 3      # configure 3 materials
    ...
  end
  ...
end
@endcode

@section inciter_newpde_pdestack 5. Augment PDE stack

Next is to augment inciter's `PDEStack`, a factory from which the PDEs are
instantiated according to user has configuration.

Class PDEStack helps with configuring and instantiating PDE class objects from
factories. There are separate factories for PDEs with continuous Galerkin (CG)
and discontinuous Galerkin (DG) finite element discretizations, declared in
PDE/PDEFactory.h: CGFactory and DGFactory. These factories are associative
containers that assign PDE class constructors to a key that uniquely identifies
a given PDE system configured to a given physics and problem policy.

First the constructors of all PDEs with all possible combinations of their
valid policies are registered into their factory. This is done by PDEStack's
constructor. Then when user input is known at runtime, i.e., we know what and
how many PDE systems, with what discretizations, and with what policies the
user wants to use, we instantiated the selected ones in PDEStack::selectedCG()
and PDEStack::selectedDG().

@note All PDE types are polymorphic and must adhere to the concept defined by
CGPDE and DGPDE. This concept is nothing else but the requirement on defining
certain member functions with given name, return value, and input arguments
(function signature). All "child" PDE classes must conform to these concepts so
they can be used from client code that is uniform, such as in DG. See also the
discussion in PDEStack's constructor.

The following diff augments PDEStack with our newly added PDE type.

@subsection inciter_newpde_pdestack PDE/PDEStack.C

@code{.diff}
git diff src/PDE/PDEStack.C
diff --git a/src/PDE/PDEStack.C b/src/PDE/PDEStack.C
index 70036aad..af1a2de7 100644
--- a/src/PDE/PDEStack.C
+++ b/src/PDE/PDEStack.C
@@ -17,6 +17,7 @@
 
 #include "ConfigureTransport.h"
 #include "ConfigureCompFlow.h"
+#include "ConfigureMultiMatCompFlow.h"
 
 using inciter::PDEStack;
 
@@ -96,6 +97,7 @@ PDEStack::PDEStack() : m_cgfactory(), m_dgfactory(),
 {
   registerTransport( m_cgfactory, m_dgfactory, m_cgEqTypes, m_dgEqTypes );
   registerCompFlow( m_cgfactory, m_dgfactory, m_cgEqTypes, m_dgEqTypes );
+  registerMultiMatCompFlow( m_dgfactory, m_dgEqTypes );
 }
 
 std::vector< inciter::CGPDE >
@@ -144,6 +146,8 @@ PDEStack::selectedDG() const
         pdes.push_back( createDG< tag::transport >( d, cnt ) );
       else if (d == ctr::PDEType::COMPFLOW)
         pdes.push_back( createDG< tag::compflow >( d, cnt ) );
+      else if (d == ctr::PDEType::MULTIMAT_COMPFLOW)
+        pdes.push_back( createDG< tag::multimat_compflow >( d, cnt ) );
       else Throw( "Can't find selected DGPDE" );
     }
 
@@ -169,6 +173,8 @@ PDEStack::info() const
       nfo.emplace_back( infoTransport( cnt ) );
     else if (d == ctr::PDEType::COMPFLOW)
       nfo.emplace_back( infoCompFlow( cnt ) );
+    else if (d == ctr::PDEType::MULTIMAT_COMPFLOW)
+      nfo.emplace_back( infoMultiMatCompFlow( cnt ) );
     else Throw( "Can't find selected PDE" );
   }
@endcode

registerMultiMatCompFlow() will be defined in ConfigureMultiMatCompFlow.[Ch].

@section inciter_newpde_buildsystem 6. Augment the PDE build object

Before adding the new (skeleton) files for the new PDE type (which will contain
their actual implementation of the spatial discretization), we add a new object
file to the PDE build object so that registration of the new PDE into PDEStack
is complete:

@subsection inciter_newpde_cmake PDE/CMakeLists.txt

@code{.diff}
git diff src/PDE/CMakeListst.txt
diff --git a/src/PDE/CMakeLists.txt b/src/PDE/CMakeLists.txt
index c2ae8d9b..76562c52 100644
--- a/src/PDE/CMakeLists.txt
+++ b/src/PDE/CMakeLists.txt
@@ -14,7 +14,8 @@ add_library(PDE
             Integrate/Riemann/RiemannFactory.C
             Limiter.C
             ConfigureTransport.C
-            ConfigureCompFlow.C)
+            ConfigureCompFlow.C
+            ConfigureMultiMatCompFlow.C)
 
 target_include_directories(PDE PUBLIC
                            ${QUINOA_SOURCE_DIR}
@endcode

@section inciter_newpde_skeletons 7. New skeleton PDE classes

Finally, we add a set of new files that will implement the new PDE using DG. As
an example, we also add a new physics and a couple of new problem policy
classs: one for a user-defined problem and another one for a verification
problem using vortical flow.

For registration into PDEStack and DGFactory:
- @subpage inciter_newpde_configuremultimatcompflow_h
- @subpage inciter_newpde_configuremultimatcompflow_c

Implementation and calls to the discretization of _all_ DG operators for
multi-material compressible flow physics:
- @subpage inciter_newpde_dgmultimatcompflow_h

Physics configuration:
- @subpage inciter_newpde_dgveleq_h -
  a new physics policy specific to velocity equilibrium
- @subpage inciter_newpde_dg_h -
  list of all MultiMatCompFlow DG physics policies

Problem configuration:
- @subpage inciter_newpde_userdefined_h -
  a new problem policy for multi-material compflow
- @subpage inciter_newpde_vorticalflow_h -
  a new problem policy specialized for the vortical flow verification problem
- @subpage inciter_newpde_problem_h -
  list of all MultiMatCompFlow problem policies.

*/
} // inciter::
