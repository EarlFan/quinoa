/*!
  \page      why Philosophy

This page describes our core software engineering values and explains why we are
motivated to work on this project. If you agree, contact as via
[GitHub](https://github.com/quinoacomputing/quinoa),
[Email](mailto:quinoa@lanl.gov) or
[Gitter](https://gitter.im/quinoacomputing/quinoa), and join us!

@m_div{m-col-t-6 m-col-m-3 m-right-t}
<img src="kattekrab-Mainframe_noshadow.svg"/>
@m_enddiv

@section exascale Designed for the exascale era

Our target machines are the largest
[distributed-memory](https://en.wikipedia.org/wiki/Distributed_memory) computers
in the world with millions of compute cores. Due to [unprecedented hardware
complexity](https://herbsutter.com/welcome-to-the-jungle) and features such as
[deep memory hierarchies](https://en.wikipedia.org/wiki/Memory_hierarchy) and
[dynamic frequency
scaling](https://en.wikipedia.org/wiki/Dynamic_frequency_scaling), we must
assume _a priori_ unknown and inhomogeneous computational load and performance
among parts of the system that can also dynamically change in time.  To
efficiently use these resources our programming paradigm must allow
_asynchronous_ parallel execution. This enables overlapping computation,
communication, input, and output. Asynchronous programming constitutes a major
paradigm shift compared to the more traditional bulk-synchronous approach,
widely applied for large-scale scientific computing, e.g., using [message
passing](https://en.wikipedia.org/wiki/Message_passing_in_computer_clusters).
We believe that the most economic utilization of future computer hardware can
only be achieved with a paradigm shift from bulk-synchronous to fully
asynchronous programming. For most computational codes this deeply affects the
programming style as well as the optimal data layout and algorithm structure
which therefore would require a complete rewrite.

Quinoa was started from scratch, instead of modifying an existing code, to
provide full freedom in exercising the asynchronous paradigm. The code is built
on the [Charm++](http://charm.cs.illinois.edu) runtime system and family of
libraries. Instead of message passing, Charm++ is founded on the
migratable-objects programming model and supported by an adaptive runtime
system. In Charm++ data and work-units interact via asynchronous function calls
enabling fully asynchronous programming. Asynchronous programming can be used to
specify task-parallelism as well as data parallelism in a single application
using a single abstraction. The interacting objects may reside on the same or on
a networked compute node and may migrate from one to another during computation.
Object migration is transparent to the application and carried out by the
runtime system based on real-time load and hardware measurement, but if needed
can be influenced by the application. Charm++ is mature, it has been actively
developed since 1989, and is used by [several large production
codes](http://charmplusplus.org/applications/). Read a one-page summary on the
strengths of Charm++ at http://charm.cs.uiuc.edu/why.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="Boton-correcto.svg"/>
@m_enddiv

@section correct Verified and proven to be correct

Nothing is more important than code that works as advertised with no surprises.
We strive for writing testable code as well as writing tests that cover the code
to the maximum degree possible. Code coverage is quantified using two
independent tools: [codecov.io](https://codecov.io) and
[gcov](https://gcc.gnu.org/onlinedocs/gcc/Gcov.html). Untested code is assumed
to be incorrect until proven otherwise.  Only with extensive [positive and
negative](http://www.dwheeler.com/essays/heartbleed.html) testing can developers
and users be assured of correctness.

In Quinoa code correctness is verified and quantified using multiple levels of
testing:
 - Our random number generator test suite, @ref rngtest_main, subjects
   generators to stringent statistical tests which enables quantitative ranking
   of all generators available with respect to their quality and computational
   cost.
 - Our unit test suite, @ref unittest_main, capable of testing serial,
   synchronous (e.g., MPI) parallel, and asynchronous parallel (e.g., Charm++)
   functions with @ref coverage "code coverage analysis" is used to test the
   smallest units of code.
 - Our regression test suite with @ref coverage "code coverage analysis" is used
   to test features larger than the smallest units, such as multiple algorithms
   coupled to solve a differential equation.
 - A [planned](http://lcamtuf.coredump.cx/afl) [fuzz
   test](https://en.wikipedia.org/wiki/Fuzz_testing) suite will help prepare
   against invalid, unexpected, or random inputs.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="Triangle.svg"/>
@m_enddiv

@section optimized Optimized for performance, power, and reliability

Power consumption is a primary concern in the exascale era. Application
performance must be measured within power constraints on increasingly complex
and thus likely less reliable hardware. A computation must optimize and thus
dynamically adapt to maximize performance constrained by power limits while
being resilient against hardware failures. This requires revolutionary methods
with a stronger-than-before integration among hardware features, system
software, and the application.

Quinoa relies on the [Charm++] (http://charm.cs.illinois.edu) runtime system.  A
central idea of Charm++ is to enable and facilitate _overdecomposition_:
computation (data and work-units) is decomposed into a large number of logical
units, usually more than the available processors. Overdecomposition enables the
runtime system to dynamically adapt the computational load monitoring
load-imbalance due to software (e.g., particle clustering, adaptive refinement)
as well as hardware (e.g., dynamic processor frequency scaling). The runtime
system also migrates data and work-units if it notices (via sensors, cache
monitors, etc.) that a compute node is about to fail. If a node fails without a
warning, the application can be restarted from a previously saved checkpoint.
Since overdecomposition is done without direct reference to physical processors,
the application can be restarted using a number of processors different than
that of the checkpoint was saved with. Resiliency is provided by the runtime
system transparent to the application and can save millions of cycles since jobs
have to be restarted less frequently due to hardware failure. Read more on
[power, reliability, and
performance](http://charm.cs.illinois.edu/newPapers/16-12/paper.pdf) from the
developers of Charm++.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="techie-arsitek.svg"/>
@m_enddiv

@section outsource Advanced computer science outsourced to experts

Hardware complexity is increasing. Simultaneously satisfying all the different
requirements enumerated here inevitably increases software complexity.
Attempting to tackle every aspect by the application programmer, as is
frequently done in a research context and sometimes also in production, does not
scale as more features are added, i.e., not economical thus unsustainable. The
combination of increasing hardware and software complexity leads to an
unprecedented degree of specialization among the software components as well as
their developers. _Picking the right tool for the right job_, components of
complex software must be outsourced to subject-matter experts.

Quinoa's goal is to provide simulation software for scientific and engineering
purposes. This involves numerically solving the differential and integral
equations of mathematical physics. Advanced computer science, such as
computational load decomposition, dynamic load balancing, object migration,
networking, parallel input and output, random number generation, hashing, etc.,
are outsourced to those who make a career out them. Quinoa uses a number of @ref
licenses "third-party libraries" and application developers closely collaborate
with subject-matter experts.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="celticknot1.svg"/>
@m_enddiv

@section language Use a programming language that can cope with complexity

The ultimate measure of the value of a computer language is how it balances
runtime performance and code complexity. A good language can do a lot for a
designer and a programmer, as long as its strengths and limitations are clearly
understood and respected.

Quinoa's main language of choice is C++ for the following reasons.

 - It offers @ref layout_comparison "uncompromising performance".

 - It is statically typed, resulting in earlier error detection, more reliable
   algorithms, and compiled code that executes quicker.

 - It supports @ref layout "data abstraction", enabling the representation of
   non-trivial concepts.

 - It allows programming using more than one programming style, each to its best
   effect; as such it supports @ref genEsup() "procedural",
   @ref walker::DiffEq "object oriented", @ref record() "generic", as well as
   [many features](https://stackoverflow.com/a/21472274) of @ref recordModel()
   "functional" programming.

 - It provides a portable [standard
   library](http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library) with
   [guaranteed algorithmic complexity](http://www.sgi.com/tech/stl/complexity.html)

[Modern C++](http://herbsutter.com/elements-of-modern-c-style/) provides great
flexibility and enables the expert programmer to implement capability to
simulate interesting (i.e., complex and practically useful) problems, using
hardware resources efficiently, yielding production quality code that is
extensible, maintainable, and thus sustainable.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="nicubunu-Tools.svg"/>
@m_enddiv

@section productivity Highly-valued programmer productivity

Due to software complexity the most expensive resource in implementing,
maintaining, and extending compute capability is the developer's time. In a
successful project programmer productivity must be highly regarded and actively
maintained. Besides a comfortable work environment and an inspiring and
motivating culture, this involves the freedom to use the best and most versatile
software engineering tools available. Only by using the latest and greatest
tools are code reuse, extensibility, maintainability, and thus productivity
maximized.

Quinoa is developed using the latest compiler technology and software
engineering tools. We believe developers of a computational physics code must be
skilled not only in physics and numerical methods but in the latest software
development techniques as well.

@m_div{m-col-t-5 m-col-m-3 m-right-t}
<img src="handshake.svg"/>
@m_enddiv

@section friendly User and developer friendly

User experience is [the most important design goal](http://resources.idgenterprise.com/original/AST-0053933_seven_qualities_of_wildly_desirable_software.pdf)
of desirable software. However, this does not necessarily require a graphical
user interface. Also, expert developers should be able to get started quickly,
extend the code in a productive manner, and tailor functionality to their or
their customer's needs.

User input in Quinoa is restricted to command-line arguments and simple-to-read
text files. The input grammar is versatile and extensible. Parsing is outsourced
to a library written by experts in that field. Error messages are friendly and
often suggest a solution. Documentation of command-line and input file keywords
is directly accessible at the user's fingertips, obtained via command-line
arguments (@code{.shell}-h@endcode, @code{.shell}-H@endcode). New keywords,
reflecting new features, are made impossible to add without proper in-code
documentation. Simulation result output is highly customizable.

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="document.svg"/>
@m_enddiv

\section documented Well documented
Undocumented code is considered legacy code and a major impediment to progress
and productivity.

Quinoa is well-documented for developers, users, administrators as well as
auditors. This includes documentation for
 - theory
 - software requirements, specification, design, implementation, and interfaces
 - verification and validation
 - user examples
 - source code control history
 - team collaboration documentation and archive
 - code correctness and quality
 - legal issues

All documentation is accessible at a single point of entry via any web browser
with no separate documents to open or print. The documentation is searchable,
indexable, and looks great on any device, including
[figures](walker_example_ou.html#walker_example_ou_pdf) and
[math](_generalized_dirichlet_8h.html#details).

@m_div{m-col-t-4 m-col-m-2 m-right-t}
<img src="Happy-Penguin.svg"/>
@m_enddiv

@section fun Fun to work on

We believe all the above are equally important in order to make this project fun
to work on. None of the above can be an afterthought: they must all be
simultaneously considered at all times and from the outset.

*/
